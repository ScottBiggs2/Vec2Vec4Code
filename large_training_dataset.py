# Large-scale training dataset for Vec2Vec code translation
# Generated on 2025-07-11 18:56:15
# Contains 73 Python and 191 C snippets

LARGE_PYTHON_SAMPLES = [
    "# findIndexBinary_ :: (a -> Ordering) -> [a] -> Maybe Int\ndef findIndexBinary_(p):\n    def go(xs):\n        def bin(lo, hi):\n            if hi < lo:\n                return None\n            else:\n                mid = (lo + hi) // 2\n                cmpr = p(xs[mid])\n                return bin(lo, mid - 1) if -1 == cmpr else (\n                    bin(mid + 1, hi) if 1 == cmpr else (\n                        mid\n                    )\n                )\n        n = len(xs)\n        return bin(0, n - 1) if 0 < n else None\n    return lambda xs: go(xs)\n\n# COMPARISON CONSTRUCTORS ---------------------------------\n\n# compare :: a -> a -> Ordering\ndef compare(a):\n    '''Simple comparison of x and y -> LT|EQ|GT'''\n    return lambda b: -1 if a < b else (1 if a > b else 0)\n\n# byKV :: (a -> b) -> a -> a -> Ordering\ndef byKV(f):\n    '''Property accessor function -> target value -> x -> LT|EQ|GT'''\n    def go(v, x):\n        fx = f(x)\n        return -1 if v < fx else 1 if v > fx else 0\n    return lambda v: lambda x: go(v, x)\n\n# TESTS ---------------------------------------------------\n\nif __name__ == '__main__':\n\n    # BINARY SEARCH FOR WORD IN AZ-SORTED LIST\n\n    mb1 = findIndexBinary_(compare('mu'))(\n        # Sorted AZ\n        ['alpha', 'beta', 'delta', 'epsilon', 'eta', 'gamma', 'iota',\n         'kappa', 'lambda', 'mu', 'theta', 'zeta']\n    )\n\n    print (\n        'Not found' if None is mb1 else (\n            'Word found at index ' + str(mb1)\n        )\n    )\n\n    # BINARY SEARCH FOR WORD OF GIVEN LENGTH (IN WORD-LENGTH SORTED LIST)\n\n    mb2 = findIndexBinary_(byKV(len)(6))(\n        # Sorted by rising length\n        ['mu', 'eta', 'beta', 'iota', 'zeta', 'alpha', 'delta', 'gamma',\n         'kappa', 'theta', 'lambda', 'epsilon']\n    )\n\n    print (\n        'Not found' if None is mb2 else (\n            'Word of given length found at index ' + str(mb2)\n        )\n    )",
    "def prevPowTwo(n):\n    'Gets the power of two that is less than or equal to the given input'\n    if ((n & -n) == n):\n        return n\n    else:\n        n -= 1\n        n |= n >> 1\n        n |= n >> 2\n        n |= n >> 4\n        n |= n >> 8\n        n |= n >> 16\n        n += 1\n        return (n/2)\n\ndef crazyFib(n):\n    'Crazy fast fibonacci number calculation'\n    powTwo = prevPowTwo(n)\n    \n    q = r = i = 1\n    s = 0\n    \n    while(i < powTwo):\n        i *= 2\n        q, r, s = q*q + r*r, r * (q + s), (r*r + s*s)\n        \n    while(i < n):\n        i += 1\n        q, r, s = q+r, q, r\n        \n    return q",
    "'''Fibonacci accumulation'''\n\nfrom itertools import accumulate\n\n# fibs :: Integer :: [Integer]\ndef fibs(n):\n    '''An accumulation of the first n integers in\n       the Fibonacci series. The accumulator is a\n       pair of the two preceding numbers.\n    '''\n    return [\n        a\n        for a, b in accumulate(\n            range(1, n),  # we don't actually use these numbers\n            lambda acc, _: (acc[1],  sum(acc)),\n            initial = (0, 1)\n        )\n    ]\n\n# MAIN ---\nif __name__ == '__main__':\n    print(f'First twenty: {fibs(20)}')",
    "'''Nth Fibonacci term (by folding)'''\n\nfrom functools import reduce\n\n# nthFib :: Integer -> Integer\ndef nthFib(n):\n    '''Nth integer in the Fibonacci series.'''\n    return reduce(\n        lambda acc, _: (acc[1], sum(acc)),\n        range(1, n),\n        (0, 1)\n    )[0]\n\n# MAIN ---\nif __name__ == '__main__':\n    n = 1000\n    print(f'{n}th term: {nthFib(n)}')",
    "def gcd_bin(u, v):\n    u, v = abs(u), abs(v) # u >= 0, v >= 0\n    if u < v:\n        u, v = v, u # u >= v >= 0\n    if v == 0:\n        return u\n   \n    # u >= v > 0\n    k = 1\n    while u & 1 == 0 and v & 1 == 0: # u, v - even\n        u >>= 1; v >>= 1\n        k <<= 1\n       \n    t = -v if u & 1 else u\n    while t:\n        while t & 1 == 0:\n            t >>= 1\n        if t > 0:\n            u = t\n        else:\n            v = -t\n        t = u - v\n    return u * k",
    "def insertion_sort_bin(seq):\n    for i in range(1, len(seq)):\n        key = seq[i]\n        # invariant: ``seq[:i]`` is sorted        \n        # find the least `low' such that ``seq[low]`` is not less then `key'.\n        #   Binary search in sorted sequence ``seq[low:up]``:\n        low, up = 0, i\n        while up > low:\n            middle = (low + up) // 2\n            if seq[middle] < key:\n                low = middle + 1              \n            else:\n                up = middle\n        # insert key at position ``low``\n        seq[:] = seq[:low] + [key] + seq[low:i] + seq[i + 1:]",
    "'''Towers of Hanoi'''\n\n# hanoi :: Int -> String -> String -> String -> [(String, String)]\ndef hanoi(n):\n    '''A list of (from, to) label pairs,\n       where a, b and c are labels for each of the\n       three Hanoi tower positions.'''\n    def go(n, a, b, c):\n        p = n - 1\n        return (\n            go(p, a, c, b) + [(a, b)] + go(p, c, b, a)\n        ) if 0 < n else []\n    return lambda a: lambda b: lambda c: go(n, a, b, c)\n\n# TEST ----------------------------------------------------\nif __name__ == '__main__':\n\n    # fromTo :: (String, String) -> String\n    def fromTo(xy):\n        '''x -> y'''\n        x, y = xy\n        return x.rjust(5, ' ') + ' -> ' + y\n\n    print(__doc__ + ':\\n\\n' + '\\n'.join(\n        map(fromTo, hanoi(4)('left')('right')('mid'))\n    ))",
    "class FIFO:  ## NOT a new-style class, must not derive from \"object\"\n   def __init__(self,*args):\n       self.contents = list(args)\n   def __call__(self):\n       return self.pop()\n   def empty(self):\n       return bool(self.contents)\n   def pop(self):\n       return self.contents.pop(0)\n   def __getattr__(self, attr):\n       return getattr(self.contents,attr)\n   def next(self):\n       if not self:\n           raise StopIteration\n       return self.pop()",
    "from collections import namedtuple\n \nNode = namedtuple('Node', 'data, left, right')\ntree = Node(1,\n            Node(2,\n                 Node(4,\n                      Node(7, None, None),\n                      None),\n                 Node(5, None, None)),\n            Node(3,\n                 Node(6,\n                      Node(8, None, None),\n                      Node(9, None, None)),\n                 None))\n \ndef printwithspace(i):\n    print(i, end=' ')\n\ndef dfs(order, node, visitor):\n    if node is not None:\n        for action in order:\n            if action == 'N':\n                visitor(node.data)\n            elif action == 'L':\n                dfs(order, node.left, visitor)\n            elif action == 'R':\n                dfs(order, node.right, visitor)\n                \ndef preorder(node, visitor = printwithspace):\n    dfs('NLR', node, visitor)\n \ndef inorder(node, visitor = printwithspace):\n    dfs('LNR', node, visitor)\n \ndef postorder(node, visitor = printwithspace):\n    dfs('LRN', node, visitor)\n \ndef ls(node, more, visitor, order='TB'):\n    \"Level-based Top-to-Bottom or Bottom-to-Top tree search\"\n    if node:\n        if more is None:\n            more = []\n        more += [node.left, node.right]\n    for action in order:\n        if action == 'B' and more:\n            ls(more[0], more[1:], visitor, order)\n        elif action == 'T' and node:\n            visitor(node.data)\n\ndef levelorder(node, more=None, visitor = printwithspace):\n    ls(node, more, visitor, 'TB') \n \n# Because we can\ndef reverse_preorder(node, visitor = printwithspace):\n    dfs('RLN', node, visitor)\n    \ndef bottom_up_order(node, more=None, visitor = printwithspace, order='BT'):\n    ls(node, more, visitor, 'BT')\n\nif __name__ == '__main__':\n    w = 10\n    for traversal in [preorder, inorder, postorder, levelorder, \n                      reverse_preorder, bottom_up_order]:\n        if traversal == reverse_preorder:\n            w = 20\n            print('\\nThe generalisation of function dfs allows:')\n        if traversal == bottom_up_order:\n            print('The generalisation of function ls allows:')\n        print(f\"{traversal.__name__:>{w}}:\", end=' ')\n        traversal(tree)\n        print()",
    "from collections import namedtuple\nfrom sys import stdout\n \nclass Node(namedtuple('Node', 'data, left, right')):\n    __slots__ = ()\n\n    def preorder(self, visitor):\n        if self is not None:\n            visitor(self.data)\n            Node.preorder(self.left, visitor)\n            Node.preorder(self.right, visitor)\n     \n    def inorder(self, visitor):\n        if self is not None:\n            Node.inorder(self.left, visitor)\n            visitor(self.data)\n            Node.inorder(self.right, visitor)\n     \n    def postorder(self, visitor):\n        if self is not None:\n            Node.postorder(self.left, visitor)\n            Node.postorder(self.right, visitor)\n            visitor(self.data)\n     \n    def levelorder(self, visitor, more=None):\n        if self is not None:\n            if more is None:\n                more = []\n            more += [self.left, self.right]\n            visitor(self.data)\n        if more:    \n            Node.levelorder(more[0], visitor, more[1:])\n\ndef printwithspace(i):\n    stdout.write(\"%i \" % i)\n\ntree = Node(1,\n            Node(2,\n                 Node(4,\n                      Node(7, None, None),\n                      None),\n                 Node(5, None, None)),\n            Node(3,\n                 Node(6,\n                      Node(8, None, None),\n                      Node(9, None, None)),\n                 None))\n\nif __name__ == '__main__':\n    stdout.write('  preorder: ')\n    tree.preorder(printwithspace)\n    stdout.write('\\n   inorder: ')\n    tree.inorder(printwithspace)\n    stdout.write('\\n postorder: ')\n    tree.postorder(printwithspace)\n    stdout.write('\\nlevelorder: ')\n    tree.levelorder(printwithspace)\n    stdout.write('\\n')",
    "# Creating a Dictionary\nDict = {'Name': 'Geeks', 1: [1, 2, 3, 4]}\nprint(\"Creating Dictionary: \")\nprint(Dict)\n\n# accessing a element using key \nprint(\"Accessing a element using key:\") \nprint(Dict['Name']) \n\n# accessing a element using get() \n# method \nprint(\"Accessing a element using get:\") \nprint(Dict.get(1)) \n\n# creation using Dictionary comprehension\nmyDict = {x: x**2 for x in [1,2,3,4,5]}\nprint(myDict)",
    "# Creating a Set with  \n# a mixed type of values \n# (Having numbers and strings) \nSet = set([1, 2, 'Geeks', 4, 'For', 6, 'Geeks']) \nprint(\"\\nSet with the use of Mixed Values\") \nprint(Set) \n\n# Accessing element using \n# for loop \nprint(\"\\nElements of set: \") \nfor i in Set: \n    print(i, end =\" \") \nprint()\n\n# Checking the element \n# using in keyword \nprint(\"Geeks\" in Set)",
    "from collections import OrderedDict\n\nprint(\"Before deleting:\\n\")\nod = OrderedDict()\nod['a'] = 1\nod['b'] = 2\nod['c'] = 3\nod['d'] = 4\n\nfor key, value in od.items():\n    print(key, value)\n\nprint(\"\\nAfter deleting:\\n\")\nod.pop('c')\nfor key, value in od.items():\n    print(key, value)\n\nprint(\"\\nAfter re-inserting:\\n\")\nod['c'] = 3\nfor key, value in od.items():\n    print(key, value)",
    "from collections import defaultdict\n\n# Defining the dict\nd = defaultdict(int)\n    \nL = [1, 2, 3, 4, 2, 4, 1, 2]\n    \n# Iterate through the list\n# for keeping the count\nfor i in L:\n        \n    # The default value is 0\n    # so there is no need to\n    # enter the key first\n    d[i] += 1\n        \nprint(d)",
    "from collections import namedtuple\n    \n# Declaring namedtuple()\nStudent = namedtuple('Student',['name','age','DOB'])\n    \n# Adding values\nS = Student('Nandini','19','2541997')\n    \n# Access using index\nprint (\"The Student age using index is : \",end =\"\")\nprint (S[1])\n    \n# Access using name\nprint (\"The Student name using keyname is : \",end =\"\")\nprint (S.name)",
    "# importing \"collections\" for deque operations\nimport collections\n\n# initializing deque\nde = collections.deque([1,2,3])\n\n# using append() to insert element at right end\n# inserts 4 at the end of deque\nde.append(4)\n\n# printing modified deque\nprint(\"The deque after appending at right is : \")\nprint(de)\n\n# using appendleft() to insert element at left end\n# inserts 6 at the beginning of deque\nde.appendleft(6)\n\n# printing modified deque\nprint(\"The deque after appending at left is : \")\nprint(de)\n\n# using pop() to delete element from right end\n# deletes 4 from the right end of deque\nde.pop()\n\n# printing modified deque\nprint(\"The deque after deleting from right is : \")\nprint(de)\n\n# using popleft() to delete element from left end\n# deletes 6 from the left end of deque\nde.popleft()\n\n# printing modified deque\nprint(\"The deque after deleting from left is : \")\nprint(de)",
    "from collections import UserDict\n\n# Creating a Dictionary where\n# deletion is not allowed\nclass MyDict(UserDict):\n    \n    # Function to stop deletion\n    # from dictionary\n    def __del__(self):\n        raise RuntimeError(\"Deletion not allowed\")\n        \n    # Function to stop pop from\n    # dictionary\n    def pop(self, s = None):\n        raise RuntimeError(\"Deletion not allowed\")\n        \n    # Function to stop popitem\n    # from Dictionary\n    def popitem(self, s = None):\n        raise RuntimeError(\"Deletion not allowed\")\n    \n# Driver's code\nd = MyDict({'a':1,\n    'b': 2,\n    'c': 3})\n\nprint(\"Original Dictionary\")\nprint(d)\n\nd.pop(1)",
    "# Python program to demonstrate\n# userlist\n\nfrom collections import UserList\n\n# Creating a List where\n# deletion is not allowed\nclass MyList(UserList):\n    \n    # Function to stop deletion\n    # from List\n    def remove(self, s = None):\n        raise RuntimeError(\"Deletion not allowed\")\n        \n    # Function to stop pop from\n    # List\n    def pop(self, s = None):\n        raise RuntimeError(\"Deletion not allowed\")\n    \n# Driver's code\nL = MyList([1, 2, 3, 4])\n\nprint(\"Original List\")\nprint(L)\n\n# Inserting to List\"\nL.append(5)\nprint(\"After Insertion\")\nprint(L)\n\n# Deleting From List\nL.remove()",
    "from collections import UserString\n\n# Creating a Mutable String\nclass Mystring(UserString):\n    \n    # Function to append to\n    # string\n    def append(self, s):\n        self.data += s\n        \n    # Function to remove from\n    # string\n    def remove(self, s):\n        self.data = self.data.replace(s, \"\")\n    \n# Driver's code\ns1 = Mystring(\"Geeks\")\nprint(\"Original String:\", s1.data)\n\n# Appending to string\ns1.append(\"s\")\nprint(\"String After Appending:\", s1.data)\n\n# Removing from string\ns1.remove(\"e\")\nprint(\"String after Removing:\", s1.data)",
    "# Node class\nclass Node:\n\n    # Function to initialize the node object\n    def __init__(self, data):\n        self.data = data # Assign data\n        self.next = None # Initialize\n                        # next as null\n\n# Linked List class\nclass LinkedList:\n    \n    # Function to initialize the Linked\n    # List object\n    def __init__(self):\n        self.head = None",
    "# A simple Python program to introduce a linked list\n\n# Node class\nclass Node:\n\n    # Function to initialise the node object\n    def __init__(self, data):\n        self.data = data # Assign data\n        self.next = None # Initialize next as null\n\n# Linked List class contains a Node object\nclass LinkedList:\n\n    # Function to initialize head\n    def __init__(self):\n        self.head = None\n\n# Code execution starts here\nif __name__=='__main__':\n\n    # Start with the empty list\n    list = LinkedList()\n\n    list.head = Node(1)\n    second = Node(2)\n    third = Node(3)\n\n    '''\n    Three nodes have been created.\n    We have references to these three blocks as head,\n    second and third\n\n    list.head     second             third\n        |             |                 |\n        |             |                 |\n    +----+------+     +----+------+     +----+------+\n    | 1 | None |     | 2 | None |     | 3 | None |\n    +----+------+     +----+------+     +----+------+\n    '''\n\n    list.head.next = second; # Link first node with second\n\n    '''\n    Now next of first Node refers to second. So they\n    both are linked.\n\n    list.head     second             third\n        |             |                 |\n        |             |                 |\n    +----+------+     +----+------+     +----+------+\n    | 1 | o-------->| 2 | null |     | 3 | null |\n    +----+------+     +----+------+     +----+------+\n    '''\n\n    second.next = third; # Link second node with the third node\n\n    '''\n    Now next of second Node refers to third. So all three\n    nodes are linked.\n\n    list.head     second             third\n        |             |                 |\n        |             |                 |\n    +----+------+     +----+------+     +----+------+\n    | 1 | o-------->| 2 | o-------->| 3 | null |\n    +----+------+     +----+------+     +----+------+\n    '''",
    "# A simple Python program for traversal of a linked list\n\n# Node class\nclass Node:\n\n    # Function to initialise the node object\n    def __init__(self, data):\n        self.data = data # Assign data\n        self.next = None # Initialize next as null\n\n# Linked List class contains a Node object\nclass LinkedList:\n\n    # Function to initialize head\n    def __init__(self):\n        self.head = None\n\n    # This function prints contents of linked list\n    # starting from head\n    def printList(self):\n        temp = self.head\n        while (temp):\n            print (temp.data)\n            temp = temp.next\n\n# Code execution starts here\nif __name__=='__main__':\n\n    # Start with the empty list\n    list = LinkedList()\n\n    list.head = Node(1)\n    second = Node(2)\n    third = Node(3)\n\n    list.head.next = second; # Link first node with second\n    second.next = third; # Link second node with the third node\n\n    list.printList()",
    "from collections import deque\n\nstack = deque()\n\n# append() function to push\n# element in the stack\nstack.append('g')\nstack.append('f')\nstack.append('g')\n\nprint('Initial stack:')\nprint(stack)\n\n# pop() function to pop\n# element from stack in\n# LIFO order\nprint('\\nElements popped from stack:')\nprint(stack.pop())\nprint(stack.pop())\nprint(stack.pop())\n\nprint('\\nStack after elements are popped:')\nprint(stack)\n\n# uncommenting print(stack.pop())\n# will cause an IndexError\n# as the stack is now empty",
    "from queue import LifoQueue\n\n# Initializing a stack\nstack = LifoQueue(maxsize = 3)\n\n# qsize() show the number of elements\n# in the stack\nprint(stack.qsize())\n\n# put() function to push\n# element in the stack\nstack.put('g')\nstack.put('f')\nstack.put('g')\n\nprint(\"Full: \", stack.full())\nprint(\"Size: \", stack.qsize())\n\n# get() function to pop\n# element from stack in\n# LIFO order\nprint('\\nElements popped from the stack')\nprint(stack.get())\nprint(stack.get())\nprint(stack.get())\n\nprint(\"\\nEmpty: \", stack.empty())",
    "from collections import deque\n\n# Initializing a queue\nq = deque()\n\n# Adding elements to a queue\nq.append('g')\nq.append('f')\nq.append('g')\n\nprint(\"Initial queue\")\nprint(q)\n\n# Removing elements from a queue\nprint(\"\\nElements dequeued from the queue\")\nprint(q.popleft())\nprint(q.popleft())\nprint(q.popleft())\n\nprint(\"\\nQueue after removing elements\")\nprint(q)\n\n# Uncommenting q.popleft()\n# will raise an IndexError\n# as queue is now empty",
    "from queue import Queue\n\n# Initializing a queue\nq = Queue(maxsize = 3)\n\n# qsize() give the maxsize\n# of the Queue\nprint(q.qsize())\n\n# Adding of element to queue\nq.put('g')\nq.put('f')\nq.put('g')\n\n# Return Boolean for Full\n# Queue\nprint(\"\\nFull: \", q.full())\n\n# Removing element from queue\nprint(\"\\nElements dequeued from the queue\")\nprint(q.get())\nprint(q.get())\nprint(q.get())\n\n# Return Boolean for Empty\n# Queue\nprint(\"\\nEmpty: \", q.empty())\n\nq.put(1)\nprint(\"\\nEmpty: \", q.empty())\nprint(\"Full: \", q.full())\n\n# This would result into Infinite\n# Loop as the Queue is empty.\n# print(q.get())",
    "# A simple implementation of Priority Queue\n# using Queue.\nclass PriorityQueue(object):\n    def __init__(self):\n        self.queue = []\n\n    def __str__(self):\n        return ' '.join([str(i) for i in self.queue])\n\n    # for checking if the queue is empty\n    def isEmpty(self):\n        return len(self.queue) == 0\n\n    # for inserting an element in the queue\n    def insert(self, data):\n        self.queue.append(data)\n\n    # for popping an element based on Priority\n    def delete(self):\n        try:\n            max = 0\n            for i in range(len(self.queue)):\n                if self.queue[i] > self.queue[max]:\n                    max = i\n            item = self.queue[max]\n            del self.queue[max]\n            return item\n        except IndexError:\n            print()\n            exit()\n\nif __name__ == '__main__':\n    myQueue = PriorityQueue()\n    myQueue.insert(12)\n    myQueue.insert(1)\n    myQueue.insert(14)\n    myQueue.insert(7)\n    print(myQueue)            \n    while not myQueue.isEmpty():\n        print(myQueue.delete())",
    "# importing \"heapq\" to implement heap queue\nimport heapq\n\n# initializing list\nli = [5, 7, 9, 1, 3]\n\n# using heapify to convert list into heap\nheapq.heapify(li)\n\n# printing created heap\nprint (\"The created heap is : \",end=\"\")\nprint (list(li))\n\n# using heappush() to push elements into heap\n# pushes 4\nheapq.heappush(li,4)\n\n# printing modified heap\nprint (\"The modified heap after push is : \",end=\"\")\nprint (list(li))\n\n# using heappop() to pop smallest element\nprint (\"The popped and smallest element is : \",end=\"\")\nprint (heapq.heappop(li))",
    "# Python program to introduce Binary Tree\n\n# A class that represents an individual node in a\n# Binary Tree\nclass Node:\n    def __init__(self,key):\n        self.left = None\n        self.right = None\n        self.val = key\n\n# create root\nroot = Node(1)\n''' following is the tree after above statement\n        1\n    / \\\n    None None'''\n\nroot.left     = Node(2);\nroot.right     = Node(3);\n\n''' 2 and 3 become left and right children of 1\n        1\n        / \\\n        2     3\n    / \\ / \\\nNone None None None'''\n\nroot.left.left = Node(4);\n'''4 becomes left child of 2\n        1\n    /     \\\n    2         3\n    / \\     / \\\nNone None None\n/ \\\nNone None'''",
    "# Python program to for tree traversals\n\n# A class that represents an individual node in a\n# Binary Tree\nclass Node:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\n# A function to do inorder tree traversal\ndef printInorder(root):\n\n    if root:\n\n        # First recur on left child\n        printInorder(root.left)\n\n        # then print the data of node\n        print(root.val),\n\n        # now recur on right child\n        printInorder(root.right)\n\n# A function to do postorder tree traversal\ndef printPostorder(root):\n\n    if root:\n\n        # First recur on left child\n        printPostorder(root.left)\n\n        # the recur on right child\n        printPostorder(root.right)\n\n        # now print the data of node\n        print(root.val),\n\n# A function to do preorder tree traversal\ndef printPreorder(root):\n\n    if root:\n\n        # First print the data of node\n        print(root.val),\n\n        # Then recur on left child\n        printPreorder(root.left)\n\n        # Finally recur on right child\n        printPreorder(root.right)\n\n# Driver code\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nprint(\"Preorder traversal of binary tree is\")\nprintPreorder(root)\n\nprint(\"\\nInorder traversal of binary tree is\")\nprintInorder(root)\n\nprint(\"\\nPostorder traversal of binary tree is\")\nprintPostorder(root)",
    "# Python program to print level\n# order traversal using Queue\n\n# A node structure\nclass Node:\n  \n    # A utility function to create a new node\n    def __init__(self ,key):\n        self.data = key\n        self.left = None\n        self.right = None\n\n# Iterative Method to print the\n# height of a binary tree\ndef printLevelOrder(root):\n  \n    # Base Case\n    if root is None:\n        return\n    \n    # Create an empty queue\n    # for level order traversal\n    queue = []\n\n    # Enqueue Root and initialize height\n    queue.append(root)\n\n    while(len(queue) > 0):\n    \n        # Print front of queue and\n        # remove it from queue\n        print (queue[0].data)\n        node = queue.pop(0)\n\n        # Enqueue left child\n        if node.left is not None:\n            queue.append(node.left)\n\n        # Enqueue right child\n        if node.right is not None:\n            queue.append(node.right)\n\n# Driver Program to test above function\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\n\nprint (\"Level Order Traversal of binary tree is -\")\nprintLevelOrder(root)",
    "# A simple representation of graph using Adjacency Matrix\nclass Graph:\n    def __init__(self,numvertex):\n        self.adjMatrix = [[-1]*numvertex for x in range(numvertex)]\n        self.numvertex = numvertex\n        self.vertices = {}\n        self.verticeslist =[0]*numvertex\n\n    def set_vertex(self,vtx,id):\n        if 0<=vtx<=self.numvertex:\n            self.vertices[id] = vtx\n            self.verticeslist[vtx] = id\n\n    def set_edge(self,frm,to,cost=0):\n        frm = self.vertices[frm]\n        to = self.vertices[to]\n        self.adjMatrix[frm][to] = cost\n        \n        # for directed graph do not add this\n        self.adjMatrix[to][frm] = cost\n\n    def get_vertex(self):\n        return self.verticeslist\n\n    def get_edges(self):\n        edges=[]\n        for i in range (self.numvertex):\n            for j in range (self.numvertex):\n                if (self.adjMatrix[i][j]!=-1):\n                    edges.append((self.verticeslist[i],self.verticeslist[j],self.adjMatrix[i][j]))\n        return edges\n        \n    def get_matrix(self):\n        return self.adjMatrix\n\nG =Graph(6)\nG.set_vertex(0,'a')\nG.set_vertex(1,'b')\nG.set_vertex(2,'c')\nG.set_vertex(3,'d')\nG.set_vertex(4,'e')\nG.set_vertex(5,'f')\nG.set_edge('a','e',10)\nG.set_edge('a','c',20)\nG.set_edge('c','b',30)\nG.set_edge('b','e',40)\nG.set_edge('e','d',50)\nG.set_edge('f','e',60)\n\nprint(\"Vertices of Graph\")\nprint(G.get_vertex())\n\nprint(\"Edges of Graph\")\nprint(G.get_edges())\n\nprint(\"Adjacency Matrix of Graph\")\nprint(G.get_matrix())",
    "# A class to represent the adjacency list of the node\nclass AdjNode:\n    def __init__(self, data):\n        self.vertex = data\n        self.next = None\n\n# A class to represent a graph. A graph\n# is the list of the adjacency lists.\n# Size of the array will be the no. of the\n# vertices \"V\"\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [None] * self.V\n\n    # Function to add an edge in an undirected graph\n    def add_edge(self, src, dest):\n      \n        # Adding the node to the source node\n        node = AdjNode(dest)\n        node.next = self.graph[src]\n        self.graph[src] = node\n\n        # Adding the source node to the destination as\n        # it is the undirected graph\n        node = AdjNode(src)\n        node.next = self.graph[dest]\n        self.graph[dest] = node\n\n    # Function to print the graph\n    def print_graph(self):\n        for i in range(self.V):\n            print(\"Adjacency list of vertex {}\\n head\".format(i), end=\"\")\n            temp = self.graph[i]\n            while temp:\n                print(\" -> {}\".format(temp.vertex), end=\"\")\n                temp = temp.next\n            print(\" \\n\")\n\n# Driver program to the above graph class\nif __name__ == \"__main__\":\n    V = 5\n    graph = Graph(V)\n    graph.add_edge(0, 1)\n    graph.add_edge(0, 4)\n    graph.add_edge(1, 2)\n    graph.add_edge(1, 3)\n    graph.add_edge(1, 4)\n    graph.add_edge(2, 3)\n    graph.add_edge(3, 4)\n\n    graph.print_graph()",
    "# Python3 Program to print BFS traversal\n# from a given source vertex. BFS(int s)\n# traverses vertices reachable from s.\nfrom collections import defaultdict\n\n# This class represents a directed graph\n# using adjacency list representation\nclass Graph:\n\n    # Constructor\n    def __init__(self):\n\n        # default dictionary to store graph\n        self.graph = defaultdict(list)\n\n    # function to add an edge to graph\n    def addEdge(self,u,v):\n        self.graph[u].append(v)\n\n    # Function to print a BFS of graph\n    def BFS(self, s):\n\n        # Mark all the vertices as not visited\n        visited = [False] * (max(self.graph) + 1)\n\n        # Create a queue for BFS\n        queue = []\n\n        # Mark the source node as\n        # visited and enqueue it\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n\n            # Dequeue a vertex from\n            # queue and print it\n            s = queue.pop(0)\n            print (s, end = \" \")\n\n            # Get all adjacent vertices of the\n            # dequeued vertex s. If a adjacent\n            # has not been visited, then mark it\n            # visited and enqueue it\n            for i in self.graph[s]:\n                if visited[i] == False:\n                    queue.append(i)\n                    visited[i] = True\n\n# Driver code\n\n# Create a graph given in\n# the above diagram\ng = Graph()\ng.addEdge(0, 1)\ng.addEdge(0, 2)\ng.addEdge(1, 2)\ng.addEdge(2, 0)\ng.addEdge(2, 3)\ng.addEdge(3, 3)\n\nprint (\"Following is Breadth First Traversal\"\n                \" (starting from vertex 2)\")\ng.BFS(2)\n\n# This code is contributed by Neelam Yadav",
    "# Python3 program to print DFS traversal\n# from a given graph\nfrom collections import defaultdict\n\n# This class represents a directed graph using\n# adjacency list representation\n\nclass Graph:\n\n    # Constructor\n    def __init__(self):\n\n        # default dictionary to store graph\n        self.graph = defaultdict(list)\n\n    # function to add an edge to graph\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n\n    # A function used by DFS\n    def DFSUtil(self, v, visited):\n\n        # Mark the current node as visited\n        # and print it\n        visited.add(v)\n        print(v, end=' ')\n\n        # Recur for all the vertices\n        # adjacent to this vertex\n        for neighbour in self.graph[v]:\n            if neighbour not in visited:\n                self.DFSUtil(neighbour, visited)\n\n    # The function to do DFS traversal. It uses\n    # recursive DFSUtil()\n    def DFS(self, v):\n\n        # Create a set to store visited vertices\n        visited = set()\n\n        # Call the recursive helper function\n        # to print DFS traversal\n        self.DFSUtil(v, visited)\n\n# Driver code\n\n# Create a graph given\n# in the above diagram\ng = Graph()\ng.addEdge(0, 1)\ng.addEdge(0, 2)\ng.addEdge(1, 2)\ng.addEdge(2, 0)\ng.addEdge(2, 3)\ng.addEdge(3, 3)\n\nprint(\"Following is DFS from (starting from vertex 2)\")\ng.DFS(2)",
    "# Program to check if a number is prime or not\n\nnum = 29\n\n# To take input from the user\n#num = int(input(\"Enter a number: \"))\n\n# define a flag variable\nflag = False\n\nif num == 0 or num == 1:\n    print(num, \"is not a prime number\")\nelif num > 1:\n    # check for factors\n    for i in range(2, num):\n        if (num % i) == 0:\n            # if factor is found, set flag to True\n            flag = True\n            # break out of loop\n            break\n\n    # check if flag is True\n    if flag:\n        print(num, \"is not a prime number\")\n    else:\n        print(num, \"is a prime number\")",
    "# Python program to find the factorial of a number provided by the user.\n\n# change the value for a different result\nnum = 7\n\n# To take input from the user\n#num = int(input(\"Enter a number: \"))\n\nfactorial = 1\n\n# check if the number is negative, positive or zero\nif num < 0:\n   print(\"Sorry, factorial does not exist for negative numbers\")\nelif num == 0:\n   print(\"The factorial of 0 is 1\")\nelse:\n   for i in range(1,num + 1):\n       factorial = factorial*i\n   print(\"The factorial of\",num,\"is\",factorial)",
    "# Program to display the Fibonacci sequence up to n-th term\n\nnterms = int(input(\"How many terms? \"))\n\n# first two terms\nn1, n2 = 0, 1\ncount = 0\n\n# check if the number of terms is valid\nif nterms <= 0:\n   print(\"Please enter a positive integer\")\n# if there is only one term, return n1\nelif nterms == 1:\n   print(\"Fibonacci sequence upto\",nterms,\":\")\n   print(n1)\n# generate fibonacci sequence\nelse:\n   print(\"Fibonacci sequence:\")\n   while count < nterms:\n       print(n1)\n       nth = n1 + n2\n       # update values\n       n1 = n2\n       n2 = nth\n       count += 1",
    "# Python program to check if year is a leap year or not\n\nyear = 2000\n\n# To get year (integer input) from the user\n# year = int(input(\"Enter a year: \"))\n\n# divided by 100 means century year (ending with 00)\n# century year divided by 400 is leap year\nif (year % 400 == 0) and (year % 100 == 0):\n    print(\"{0} is a leap year\".format(year))\n\n# not divided by 100 means not a century year\n# year divided by 4 is a leap year\nelif (year % 4 ==0) and (year % 100 != 0):\n    print(\"{0} is a leap year\".format(year))\n\n# if not divided by both 400 (century year) and 4 (not century year)\n# year is not leap year\nelse:\n    print(\"{0} is not a leap year\".format(year))",
    "# This function adds two numbers\ndef add(x, y):\n    return x + y\n\n# This function subtracts two numbers\ndef subtract(x, y):\n    return x - y\n\n# This function multiplies two numbers\ndef multiply(x, y):\n    return x * y\n\n# This function divides two numbers\ndef divide(x, y):\n    return x / y\n\nprint(\"Select operation.\")\nprint(\"1.Add\")\nprint(\"2.Subtract\")\nprint(\"3.Multiply\")\nprint(\"4.Divide\")\n\nwhile True:\n    # take input from the user\n    choice = input(\"Enter choice(1/2/3/4): \")\n\n    # check if choice is one of the four options\n    if choice in ('1', '2', '3', '4'):\n        try:\n            num1 = float(input(\"Enter first number: \"))\n            num2 = float(input(\"Enter second number: \"))\n        except ValueError:\n            print(\"Invalid input. Please enter a number.\")\n            continue\n\n        if choice == '1':\n            print(num1, \"+\", num2, \"=\", add(num1, num2))\n\n        elif choice == '2':\n            print(num1, \"-\", num2, \"=\", subtract(num1, num2))\n\n        elif choice == '3':\n            print(num1, \"*\", num2, \"=\", multiply(num1, num2))\n\n        elif choice == '4':\n            print(num1, \"/\", num2, \"=\", divide(num1, num2))\n        \n        # check if user wants another calculation\n        # break the while loop if answer is no\n        next_calculation = input(\"Let's do next calculation? (yes/no): \")\n        if next_calculation == \"no\":\n          break\n    else:\n        print(\"Invalid Input\")",
    "# Solve the quadratic equation ax**2 + bx + c = 0\n\n# import complex math module\nimport cmath\n\na = 1\nb = 5\nc = 6\n\n# calculate the discriminant\nd = (b**2) - (4*a*c)\n\n# find two solutions\nsol1 = (-b-cmath.sqrt(d))/(2*a)\nsol2 = (-b+cmath.sqrt(d))/(2*a)\n\nprint('The solution are {0} and {1}'.format(sol1,sol2))",
    "# Python program to find the largest number among the three input numbers\n\n# change the values of num1, num2 and num3\n# for a different result\nnum1 = 10\nnum2 = 14\nnum3 = 12\n\n# uncomment following lines to take three numbers from user\n#num1 = float(input(\"Enter first number: \"))\n#num2 = float(input(\"Enter second number: \"))\n#num3 = float(input(\"Enter third number: \"))\n\nif (num1 >= num2) and (num1 >= num3):\n   largest = num1\nelif (num2 >= num1) and (num2 >= num3):\n   largest = num2\nelse:\n   largest = num3\n\nprint(\"The largest number is\", largest)",
    "# Python program to display all the prime numbers within an interval\n\nlower = 900\nupper = 1000\n\nprint(\"Prime numbers between\", lower, \"and\", upper, \"are:\")\n\nfor num in range(lower, upper + 1):\n   # all prime numbers are greater than 1\n   if num > 1:\n       for i in range(2, num):\n           if (num % i) == 0:\n               break\n       else:\n           print(num)",
    "# Python program to check if the number is an Armstrong number or not\n\n# take input from the user\nnum = int(input(\"Enter a number: \"))\n\n# initialize sum\nsum = 0\n\n# find the sum of the cube of each digit\ntemp = num\nwhile temp > 0:\n   digit = temp % 10\n   sum += digit ** 3\n   temp //= 10\n\n# display the result\nif num == sum:\n   print(num,\"is an Armstrong number\")\nelse:\n   print(num,\"is not an Armstrong number\")",
    "# Program to check Armstrong numbers in a certain interval\n\nlower = 100\nupper = 2000\n\nfor num in range(lower, upper + 1):\n\n   # order of number\n   order = len(str(num))\n    \n   # initialize sum\n   sum = 0\n\n   temp = num\n   while temp > 0:\n       digit = temp % 10\n       sum += digit ** order\n       temp //= 10\n\n   if num == sum:\n       print(num)",
    "# Sum of natural numbers up to num\n\nnum = 16\n\nif num < 0:\n   print(\"Enter a positive number\")\nelse:\n   sum = 0\n   # use while loop to iterate until zero\n   while(num > 0):\n       sum += num\n       num -= 1\n   print(\"The sum is\", sum)",
    "# Display the powers of 2 using anonymous function\n\nterms = 10\n\n# Uncomment code below to take input from the user\n# terms = int(input(\"How many terms? \"))\n\n# use anonymous function\nresult = list(map(lambda x: 2 ** x, range(terms)))\n\nprint(\"The total terms are:\",terms)\nfor i in range(terms):\n   print(\"2 raised to power\",i,\"is\",result[i])",
    "# Python program to find H.C.F of two numbers\n\n# define a function\ndef compute_hcf(x, y):\n\n# choose the smaller number\n    if x > y:\n        smaller = y\n    else:\n        smaller = x\n    for i in range(1, smaller+1):\n        if((x % i == 0) and (y % i == 0)):\n            hcf = i \n    return hcf\n\nnum1 = 54 \nnum2 = 24\n\nprint(\"The H.C.F. is\", compute_hcf(num1, num2))",
    "# Python Program to find the L.C.M. of two input number\n\ndef compute_lcm(x, y):\n\n   # choose the greater number\n   if x > y:\n       greater = x\n   else:\n       greater = y\n\n   while(True):\n       if((greater % x == 0) and (greater % y == 0)):\n           lcm = greater\n           break\n       greater += 1\n\n   return lcm\n\nnum1 = 54\nnum2 = 24\n\nprint(\"The L.C.M. is\", compute_lcm(num1, num2))",
    "# Python program to shuffle a deck of card\n\n# importing modules\nimport itertools, random\n\n# make a deck of cards\ndeck = list(itertools.product(range(1,14),['Spade','Heart','Diamond','Club']))\n\n# shuffle the cards\nrandom.shuffle(deck)\n\n# draw five cards\nprint(\"You got:\")\nfor i in range(5):\n   print(deck[i][0], \"of\", deck[i][1])",
    "# Program to display calendar of the given month and year\n\n# importing calendar module\nimport calendar\n\nyy = 2014  # year\nmm = 11    # month\n\n# To take month and year input from the user\n# yy = int(input(\"Enter year: \"))\n# mm = int(input(\"Enter month: \"))\n\n# display the calendar\nprint(calendar.month(yy, mm))",
    "# Python program to display the Fibonacci sequence\n\ndef recur_fibo(n):\n   if n <= 1:\n       return n\n   else:\n       return(recur_fibo(n-1) + recur_fibo(n-2))\n\nnterms = 10\n\n# check if the number of terms is valid\nif nterms <= 0:\n   print(\"Plese enter a positive integer\")\nelse:\n   print(\"Fibonacci sequence:\")\n   for i in range(nterms):\n       print(recur_fibo(i))",
    "# Python program to find the sum of natural using recursive function\n\ndef recur_sum(n):\n   if n <= 1:\n       return n\n   else:\n       return n + recur_sum(n-1)\n\n# change this value for a different result\nnum = 16\n\nif num < 0:\n   print(\"Enter a positive number\")\nelse:\n   print(\"The sum is\",recur_sum(num))",
    "# Factorial of a number using recursion\n\ndef recur_factorial(n):\n   if n == 1:\n       return n\n   else:\n       return n*recur_factorial(n-1)\n\nnum = 7\n\n# check if the number is negative\nif num < 0:\n   print(\"Sorry, factorial does not exist for negative numbers\")\nelif num == 0:\n   print(\"The factorial of 0 is 1\")\nelse:\n   print(\"The factorial of\", num, \"is\", recur_factorial(num))",
    "# Program to add two matrices using nested loop\n\nX = [[12,7,3],\n    [4 ,5,6],\n    [7 ,8,9]]\n\nY = [[5,8,1],\n    [6,7,3],\n    [4,5,9]]\n\nresult = [[0,0,0],\n         [0,0,0],\n         [0,0,0]]\n\n# iterate through rows\nfor i in range(len(X)):\n   # iterate through columns\n   for j in range(len(X[0])):\n       result[i][j] = X[i][j] + Y[i][j]\n\nfor r in result:\n   print(r)",
    "# Program to transpose a matrix using a nested loop\n\nX = [[12,7],\n    [4 ,5],\n    [3 ,8]]\n\nresult = [[0,0,0],\n         [0,0,0]]\n\n# iterate through rows\nfor i in range(len(X)):\n   # iterate through columns\n   for j in range(len(X[0])):\n       result[j][i] = X[i][j]\n\nfor r in result:\n   print(r)",
    "# Program to multiply two matrices using nested loops\n\n# 3x3 matrix\nX = [[12,7,3],\n    [4 ,5,6],\n    [7 ,8,9]]\n# 3x4 matrix\nY = [[5,8,1,2],\n    [6,7,3,0],\n    [4,5,9,1]]\n# result is 3x4\nresult = [[0,0,0,0],\n         [0,0,0,0],\n         [0,0,0,0]]\n\n# iterate through rows of X\nfor i in range(len(X)):\n   # iterate through columns of Y\n   for j in range(len(Y[0])):\n       # iterate through rows of Y\n       for k in range(len(Y)):\n           result[i][j] += X[i][k] * Y[k][j]\n\nfor r in result:\n   print(r)",
    "# Program to check if a string is palindrome or not\n\nmy_str = 'aIbohPhoBiA'\n\n# make it suitable for caseless comparison\nmy_str = my_str.casefold()\n\n# reverse the string\nrev_str = reversed(my_str)\n\n# check if the string is equal to its reverse\nif list(my_str) == list(rev_str):\n   print(\"The string is a palindrome.\")\nelse:\n   print(\"The string is not a palindrome.\")",
    "# define punctuation\npunctuations = '''!()-[]{};:'\"\\,<>./?@#$%^&*_~'''\n\nmy_str = \"Hello!!!, he said ---and went.\"\n\n# To take input from the user\n# my_str = input(\"Enter a string: \")\n\n# remove punctuation from the string\nno_punct = \"\"\nfor char in my_str:\n   if char not in punctuations:\n       no_punct = no_punct + char\n\n# display the unpunctuated string\nprint(no_punct)",
    "# Program to sort alphabetically the words form a string provided by the user\n\nmy_str = \"Hello this Is an Example With cased letters\"\n\n# To take input from the user\n#my_str = input(\"Enter a string: \")\n\n# breakdown the string into a list of words\nwords = [word.lower() for word in my_str.split()]\n\n# sort the list\nwords.sort()\n\n# display the sorted words\n\nprint(\"The sorted words are:\")\nfor word in words:\n   print(word)",
    "# Program to count the number of each vowels\n\n# string of vowels\nvowels = 'aeiou'\n\nip_str = 'Hello, have you tried our tutorial section yet?'\n\n# make it suitable for caseless comparisions\nip_str = ip_str.casefold()\n\n# make a dictionary with each vowel a key and value 0\ncount = {}.fromkeys(vowels,0)\n\n# count the vowels\nfor char in ip_str:\n   if char in count:\n       count[char] += 1\n\nprint(count)",
    "# Python program to mail merger\n# Names are in the file names.txt\n# Body of the mail is in body.txt\n\n# open names.txt for reading\nwith open(\"names.txt\", 'r', encoding='utf-8') as names_file:\n\n    # open body.txt for reading\n    with open(\"body.txt\", 'r', encoding='utf-8') as body_file:\n\n        # read entire content of the body\n        body = body_file.read()\n\n        # iterate over names\n        for name in names_file:\n            mail = \"Hello \" + name.strip() + \"\\n\" + body\n\n            # write the mails to individual files\n            with open(name.strip()+\".txt\", 'w', encoding='utf-8') as mail_file:\n                mail_file.write(mail)",
    "def jpeg_res(filename):\n   \"\"\"\"This function prints the resolution of the jpeg image file passed into it\"\"\"\n\n   # open image for reading in binary mode\n   with open(filename,'rb') as img_file:\n\n       # height of image (in 2 bytes) is at 164th position\n       img_file.seek(163)\n\n       # read the 2 bytes\n       a = img_file.read(2)\n\n       # calculate height\n       height = (a[0] << 8) + a[1]\n\n       # next 2 bytes is width\n       a = img_file.read(2)\n\n       # calculate width\n       width = (a[0] << 8) + a[1]\n\n   print(\"The resolution of the image is\",width,\"x\",height)\n\njpeg_res(\"img1.jpg\")",
    "# Python program to find the SHA-1 message digest of a file\n\n# importing the hashlib module\nimport hashlib\n\ndef hash_file(filepath):\n   \"\"\"\"This function returns the SHA-1 hash\n   of the file passed into it\"\"\"\n\n   # make a hash object\n   h = hashlib.sha1()\n\n   # open file for reading in binary mode\n   with open(filepath,'rb') as file:\n\n       # loop till the end of the file\n       chunk = 0\n       while chunk != b'':\n           # read only 1024 bytes at a time\n           chunk = file.read(1024)\n           h.update(chunk)\n\n   # return the hex representation of digest\n   return h.hexdigest()\n\nmessage = hash_file(\"track1.mp3\")    # Use path of the file\nprint(message)",
    "rows = int(input(\"Enter number of rows: \"))\n\nk = 0\n\nfor i in range(1, rows+1):\n    for space in range(1, (rows-i)+1):\n        print(end=\"  \")\n   \n    while k!=(2*i-1):\n        print(\"* \", end=\"\")\n        k += 1\n   \n    k = 0\n    print()",
    "class Polygon:\n    def sides_no(self):\n        pass\n\nclass Triangle(Polygon):\n    def area(self):\n        pass\n\nobj_polygon = Polygon()\nobj_triangle = Triangle()\n\nprint(type(obj_triangle) == Triangle)   	# true\nprint(type(obj_triangle) == Polygon)    	# false\n\nprint(isinstance(obj_polygon, Polygon)) 	# true\nprint(isinstance(obj_triangle, Polygon))	# true",
    "from enum import Enum\n\nclass Day(Enum):\n    MONDAY = 1\n    TUESDAY = 2\n    WEDNESDAY = 3\n\n# print the enum member\nprint(Day.MONDAY)\n\n# get the name of the enum member\nprint(Day.MONDAY.name)\n\n# get the value of the enum member\nprint(Day.MONDAY.value)",
    "import itertools\n\nlist_1 = [1, 2, 3, 4]\nlist_2 = ['a', 'b', 'c']\n\n# loop until the short loop stops\nfor i,j in zip(list_1,list_2):\n    print(i,j)\n\nprint(\"\\n\")\n\n# loop until the longer list stops\nfor i,j in itertools.zip_longest(list_1,list_2):\n    print(i,j)",
    "def get_permutation(string, i=0):\n\n    if i == len(string):   	 \n        print(\"\".join(string))\n\n    for j in range(i, len(string)):\n\n        words = [c for c in string]\n   \n        # swap\n        words[i], words[j] = words[j], words[i]\n   	 \n        get_permutation(words, i + 1)\n\nprint(get_permutation('yup'))",
    "import time\n\ndef countdown(time_sec):\n    while time_sec:\n        mins, secs = divmod(time_sec, 60)\n        timeformat = '{:02d}:{:02d}'.format(mins, secs)\n        print(timeformat, end='\\r')\n        time.sleep(1)\n        time_sec -= 1\n\n    print(\"stop\")\n\ncountdown(5)",
    "def binary_search_variant(arr, target, left=0, right=None):\n    if right is None:\n        right = len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
    "class SimpleQueue:\n    def __init__(self, maxsize=None):\n        self.items = []\n        self.maxsize = maxsize\n    \n    def enqueue(self, item):\n        if self.maxsize and len(self.items) >= self.maxsize:\n            raise Exception('Queue is full')\n        self.items.append(item)\n    \n    def dequeue(self):\n        if not self.items:\n            raise Exception('Queue is empty')\n        return self.items.pop(0)\n    \n    def is_empty(self):\n        return len(self.items) == 0",
    "def string_utils(text, operation='reverse'):\n    if operation == 'reverse':\n        return text[::-1]\n    elif operation == 'uppercase':\n        return text.upper()\n    elif operation == 'word_count':\n        return len(text.split())\n    elif operation == 'char_frequency':\n        freq = {}\n        for char in text:\n            freq[char] = freq.get(char, 0) + 1\n        return freq\n    return text",
]

LARGE_C_SAMPLES = [
    "// initially called with low = 0, high = N-1\n  BinarySearch(A[0..N-1], value, low, high) {\n      // invariants: value > A[i] for all i < low\n                     value < A[i] for all i > high\n      if (high < low)\n          return not_found // value would be inserted at index \"low\"\n      mid = (low + high) / 2\n      if (A[mid] > value)\n          return BinarySearch(A, value, low, mid-1)\n      else if (A[mid] < value)\n          return BinarySearch(A, value, mid+1, high)\n      else\n          return mid\n  }",
    "BinarySearch(A[0..N-1], value) {\n      low = 0\n      high = N - 1\n      while (low <= high) {\n          // invariants: value > A[i] for all i < low\n                         value < A[i] for all i > high\n          mid = (low + high) / 2\n          if (A[mid] > value)\n              high = mid - 1\n          else if (A[mid] < value)\n              low = mid + 1\n          else\n              return mid\n      }\n      return not_found // value would be inserted at index \"low\"\n  }",
    "BinarySearch_Left(A[0..N-1], value) {\n      low = 0\n      high = N - 1\n      while (low <= high) {\n          // invariants: value > A[i] for all i < low\n                         value <= A[i] for all i > high\n          mid = (low + high) / 2\n          if (A[mid] >= value)\n              high = mid - 1\n          else\n              low = mid + 1\n      }\n      return low\n  }",
    "BinarySearch_Right(A[0..N-1], value) {\n      low = 0\n      high = N - 1\n      while (low <= high) {\n          // invariants: value >= A[i] for all i < low\n                         value < A[i] for all i > high\n          mid = (low + high) / 2\n          if (A[mid] > value)\n              high = mid - 1\n          else\n              low = mid + 1\n      }\n      return low\n  }",
    "(defun defarray (name size initial-element)\n   (cons name\n         (compress1 name\n                    (cons (list :HEADER\n                                :DIMENSIONS (list size)\n                                :MAXIMUM-LENGTH (1+ size)\n                                :DEFAULT initial-element\n                                :NAME name)\n                                nil))))\n\n(defconst *dim* 100000)\n\n(defun array-name (array)\n   (first array))\n       \n(defun set-at (array i val)\n   (cons (array-name array)\n         (aset1 (array-name array)\n                (cdr array)\n                i\n                val)))\n\n(defun populate-array-ordered (array n)\n   (if (zp n)\n       array\n       (populate-array-ordered (set-at array\n                                       (- *dim* n)\n                                       (- *dim* n))\n                               (1- n))))\n(include-book \"arithmetic-3/top\" :dir :system)\n\n(defun binary-search-r (needle haystack low high)\n   (declare (xargs :measure (nfix (1+ (- high low)))))\n   (let* ((mid (floor (+ low high) 2))\n          (current (aref1 (array-name haystack)\n                          (cdr haystack)\n                          mid)))\n         (cond ((not (and (natp low) (natp high))) nil)\n               ((= current needle)\n                mid)\n               ((zp (1+ (- high low))) nil)\n               ((> current needle)\n                (binary-search-r needle\n                                 haystack\n                                 low\n                                 (1- mid)))\n               (t (binary-search-r needle\n                                   haystack\n                                   (1+ mid)\n                                   high)))))\n\n(defun binary-search (needle haystack)\n   (binary-search-r needle haystack 0\n                    (maximum-length (array-name haystack)\n                                    (cdr haystack))))\n\n(defun test-bsearch (needle)\n   (binary-search needle\n                  (populate-array-ordered\n                   (defarray 'haystack *dim* 0)\n                   *dim*)))",
    "on binarySearch(n, theList, l, r)\n    repeat until (l = r)\n        set m to (l + r) div 2\n        if (item m of theList < n) then\n            set l to m + 1\n        else\n            set r to m\n        end if\n    end repeat\n    \n    if (item l of theList is n) then return l\n    return missing value\nend binarySearch\n\non test(n, theList, l, r)\n    set |result| to binarySearch(n, theList, l, r)\n    if (|result| is missing value) then\n        return (n as text) & \" is not in range \" & l & \" thru \" & r & \" of the list\"\n    else\n        return \"The first occurrence of \" & n & \" in range \" & l & \" thru \" & r & \" of the list is at index \" & |result|\n    end if\nend test\n\nset theList to {1, 2, 3, 3, 5, 7, 7, 8, 9, 10, 11, 12}\nreturn test(7, theList, 4, 11) & linefeed & test(7, theList, 7, 12) & linefeed & test(7, theList, 1, 5)",
    "array := \"1,2,4,6,8,9\"\nStringSplit, A, array, `,   ; creates associative array\nMsgBox % x := BinarySearch(A, 4, 1, A0) ; Recursive\nMsgBox % A%x%\nMsgBox % x := BinarySearchI(A, A0, 4)  ; Iterative\nMsgBox % A%x%\n\nBinarySearch(A, value, low, high) { ; A0 contains length of array\n  If (high < low)               ; A1, A2, A3...An are array elements\n    Return not_found\n  mid := Floor((low + high) / 2)\n  If (A%mid% > value) ; A%mid% is automatically global since no such locals are present\n    Return BinarySearch(A, value, low, mid - 1)\n  Else If (A%mid% < value)\n    Return BinarySearch(A, value, mid + 1, high)\n  Else\n    Return mid\n}\n\nBinarySearchI(A, lengthA, value) {\n  low := 0\n  high := lengthA - 1\n  While (low <= high) {\n    mid := Floor((low + high) / 2) ; round to lower integer\n    If (A%mid% > value)   \n      high := mid - 1\n    Else If (A%mid% < value)\n      low := mid + 1\n    Else\n      Return mid\n  }\n  Return not_found\n}",
    "rem Binary search\ncls\ndim a(10)\nn% = 10\nfor i% = 0 to 9 : read a(i%) : next i%\nrem Sorted data\ndata -31,0,1,2,2,4,65,83,99,782\nx = 2 : gosub 280\ngosub 230\nx = 5 : gosub 280\ngosub 230\nend\nrem Print result\nprint x;\nif indx% >= 0 then print \"is at index \";str$(indx%);\".\" else print \"is not found.\"\nreturn\nrem Binary search algorithm\nrem N% - number of elements; X - searched element; Result: INDX% - index of X\nl% = 0 : h% = n%-1 : found% = 0\nwhile (l% <= h%) and  not found%\nm% = l%+int((h%-l%)/2)\nif a(m%) < x then l% = m%+1 else if a(m%) > x then h% = m%-1 else found% = -1\nwend\nif found% = 0 then indx% = -1 else indx% = m%\nreturn",
    "sub floor(n)\n    return int(n + .5)\nend sub\n\nsub binarySearch(list(), value)\n    local low, high, mid\n    \n    low = 1 : high = arraysize(list(), 1)\n\n    while(low <= high)\n        mid = floor((low + high) / 2)\n        if list(mid) > value then\n            high = mid - 1\n        elsif list(mid) < value then\n            low = mid + 1\n        else\n            return mid\n        end if\n    wend\n    return false\nend sub\n\nITEMS = 10e6\n\ndim list(ITEMS)\n\nfor n = 1 to ITEMS\n    list(n) = n\nnext n\n\nprint binarySearch(list(), 3)\nprint peek(\"millisrunning\")",
    "#include <stdio.h>\n\nint bsearch (int *a, int n, int x) {\n    int i = 0, j = n - 1;\n    while (i <= j) {\n        int k = i + ((j - i) / 2);\n        if (a[k] == x) {\n            return k;\n        }\n        else if (a[k] < x) {\n            i = k + 1;\n        }\n        else {\n            j = k - 1;\n        }\n    }\n    return -1;\n}\n\nint bsearch_r (int *a, int x, int i, int j) {\n    if (j < i) {\n        return -1;\n    }\n    int k = i + ((j - i) / 2);\n    if (a[k] == x) {\n        return k;\n    }\n    else if (a[k] < x) {\n        return bsearch_r(a, x, k + 1, j);\n    }\n    else {\n        return bsearch_r(a, x, i, k - 1);\n    }\n}\n\nint main () {\n    int a[] = {-31, 0, 1, 2, 2, 4, 65, 83, 99, 782};\n    int n = sizeof a / sizeof a[0];\n    int x = 2;\n    int i = bsearch(a, n, x);\n    if (i >= 0)  \n      printf(\"%d is at index %d.\\n\", x, i);\n    else\n      printf(\"%d is not found.\\n\", x);\n    x = 5;\n    i = bsearch_r(a, x, 0, n - 1);\n    if (i >= 0)  \n      printf(\"%d is at index %d.\\n\", x, i);\n    else\n      printf(\"%d is not found.\\n\", x);\n    return 0;\n}",
    "//#define UseRecursiveSearch\n\nusing System;\nusing Search;\n\nclass Program {\n  static readonly int[][] tests = {\n    new int[] { },\n    new int[] { 2 },\n    new int[] { 2, 2 },\n    new int[] { 2, 2, 2, 2 },\n    new int[] { 3, 3, 4, 4 },\n    new int[] { 0, 1, 3, 3, 4, 4 },\n    new int[] { 0, 1, 2, 2, 2, 3, 3, 4, 4},\n    new int[] { 0, 1, 1, 2, 2, 2, 3, 3, 4, 4 },\n    new int[] { 0, 1, 1, 1, 1, 2, 2, 3, 3, 4, 4 },\n    new int[] { 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4 },\n    new int[] { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4 },\n  };\n\n  static void Main(string[] args) {\n    var index = 0;\n    foreach (var test in tests) {\n      var join = String.Join(\" \", test);\n      Console.WriteLine($\"test[{index}]: {join}\");\n#if UseRecursiveSearch\n      var glb = test.RecursiveBinarySearchForGLB(2);\n      var lub = test.RecursiveBinarySearchForLUB(2);\n#else\n      var glb = test.BinarySearchForGLB(2);\n      var lub = test.BinarySearchForLUB(2);\n#endif\n      Console.WriteLine($\"glb = {glb}\");\n      Console.WriteLine($\"lub = {lub}\");\n\n      index++;\n    }\n#if DEBUG\n    Console.Write(\"Press Enter\");\n    Console.ReadLine();\n#endif\n  }\n}",
    "template <class T> int binsearch(const T array[], int low, int high, T value) {\n    if (high < low) {\n        return -1;\n    }\n    auto mid = (low + high) / 2;\n    if (value < array[mid]) {\n        return binsearch(array, low, mid - 1, value);\n    } else if (value > array[mid]) {\n        return binsearch(array, mid + 1, high, value);\n    }\n    return mid;\n}\n\n#include <iostream>\nint main()\n{\n  int array[] = {2, 3, 5, 6, 8};\n  int result1 = binsearch(array, 0, sizeof(array)/sizeof(int), 4),\n      result2 = binsearch(array, 0, sizeof(array)/sizeof(int), 8);\n  if (result1 == -1) std::cout << \"4 not found!\" << std::endl;\n  else std::cout << \"4 found at \" << result1 << std::endl;\n  if (result2 == -1) std::cout << \"8 not found!\" << std::endl;\n  else std::cout << \"8 found at \" << result2 << std::endl;\n\n  return 0;\n}",
    "template <class T>\nint binSearch(const T arr[], int len, T what) {\n  int low = 0;\n  int high = len - 1;\n  while (low <= high) {\n    int mid = (low + high) / 2;\n    if (arr[mid] > what)\n      high = mid - 1;\n    else if (arr[mid] < what)\n      low = mid + 1;\n    else\n      return mid;\n  }\n  return -1; // indicate not found \n}",
    "proc binsearch(A : [], value) \n{\n        var low = A.domain.dim(0).low;\n        var high = A.domain.dim(0).high;\n        while (low <= high) \n        {\n                var mid = (low + high) / 2;\n\n                if A(mid) > value then\n                        high = mid - 1;\n                else if A(mid) < value then\n                        low = mid + 1;\n                else\n                        return mid;\n        }\n        return 0;\n}\n\nwriteln(binsearch([3, 4, 6, 9, 11], 9));",
    "(defn bsearch\n  ([coll t]\n    (bsearch coll 0 (dec (count coll)) t))\n  ([coll l u t]\n    (if (> l u) -1\n      (let [m (quot (+ l u) 2) mth (nth coll m)]\n        (cond\n          ; the middle element is greater than t\n          ; so search the lower half\n          (> mth t) (recur coll l (dec m) t)\n          ; the middle element is less than t\n          ; so search the upper half\n          (< mth t) (recur coll (inc m) u t)\n          ; we've found our target\n          ; so return its index\n          (= mth t) m)))))",
    "import std.stdio, std.array, std.range, std.traits;\n\n/// Recursive.\nbool binarySearch(R, T)(/*in*/ R data, in T x) pure nothrow @nogc\nif (isRandomAccessRange!R && is(Unqual!T == Unqual!(ElementType!R))) {\n    if (data.empty)\n        return false;\n    immutable i = data.length / 2;\n    immutable mid = data[i];\n    if (mid > x)\n        return data[0 .. i].binarySearch(x);\n    if (mid < x)\n        return data[i + 1 .. $].binarySearch(x);\n    return true;\n}\n\n/// Iterative.\nbool binarySearchIt(R, T)(/*in*/ R data, in T x) pure nothrow @nogc\nif (isRandomAccessRange!R && is(Unqual!T == Unqual!(ElementType!R))) {\n    while (!data.empty) {\n        immutable i = data.length / 2;\n        immutable mid = data[i];\n        if (mid > x)\n            data = data[0 .. i];\n        else if (mid < x)\n            data = data[i + 1 .. $];\n        else\n            return true;\n    }\n    return false;\n}\n\nvoid main() {\n    /*const*/ auto items = [2, 4, 6, 8, 9].assumeSorted;\n    foreach (const x; [1, 8, 10, 9, 5, 2])\n        writefln(\"%2d %5s %5s %5s\", x,\n                 items.binarySearch(x),\n                 items.binarySearchIt(x),\n                 // Standard Binary Search:\n                 !items.equalRange(x).empty);\n}",
    "/** Returns null if the value is not found. */\ndef binarySearch(collection, value) {\n    var low := 0\n    var high := collection.size() - 1\n    while (low <= high) {\n        def mid := (low + high) // 2\n        def comparison := value.op__cmp(collection[mid])\n        if      (comparison.belowZero()) { high := mid - 1 } \\\n        else if (comparison.aboveZero()) { low := mid + 1 }  \\\n        else if (comparison.isZero())    { return mid }      \\\n        else                             { throw(\"You expect me to binary search with a partial order?\") }\n    }\n    return null\n}",
    "recursive function binarySearch_R (a, value) result (bsresult)\n    real, intent(in) :: a(:), value\n    integer          :: bsresult, mid\n    \n    mid = size(a)/2 + 1\n    if (size(a) == 0) then\n        bsresult = 0        ! not found\n    else if (a(mid) > value) then\n        bsresult= binarySearch_R(a(:mid-1), value)\n    else if (a(mid) < value) then\n        bsresult = binarySearch_R(a(mid+1:), value)\n        if (bsresult /= 0) then\n            bsresult = mid + bsresult\n        end if\n    else\n        bsresult = mid      ! SUCCESS!!\n    end if\nend function binarySearch_R",
    "function binarySearch_I (a, value)\n    integer                  :: binarySearch_I\n    real, intent(in), target :: a(:)\n    real, intent(in)         :: value\n    real, pointer            :: p(:)\n    integer                  :: mid, offset\n    \n    p => a\n    binarySearch_I = 0\n    offset = 0\n    do while (size(p) > 0)\n        mid = size(p)/2 + 1\n        if (p(mid) > value) then\n            p => p(:mid-1)\n        else if (p(mid) < value) then\n            offset = offset + mid\n            p => p(mid+1:)\n        else\n            binarySearch_I = offset + mid    ! SUCCESS!!\n            return\n        end if\n    end do\nend function binarySearch_I",
    "include \"NSLog.incl\"\n\nNSInteger local fn BinarySearch( array as CFArrayRef, key as CFTypeRef )\nNSInteger lo = 0\nNSInteger hi = len(array) - 1\nwhile ( lo <= hi )\n  NSInteger i = lo + (hi - lo) / 2\n  CFTypeRef midVal = array[i]\n  select ( fn NumberCompare( midVal, key ) )\n    case NSOrderedAscending\n      lo = i + 1\n    case NSOrderedDescending\n      hi = i - 1\n    case NSOrderedSame:\n      return i\n  end select\nwend\nend fn = NSNotFound\n\nvoid local fn DoIt\n  CFArrayRef a = @[@1, @3, @4, @5, @6, @7, @8, @9, @10]\n  NSLog(@\"6 is at position %d\", fn BinarySearch( a, @6 ) ) // prints 4\nend fn\n\nfn DoIt\n\nHandleEvents",
    "include \"NSLog.incl\"\n\nNSInteger local fn BinarySearch( array as CFArrayRef, key as CFTypeRef )\nNSInteger lo = 0\ninclude \"NSLog.incl\"\n\nNSInteger local fn BinarySearch( array as CFArrayRef, key as CFTypeRef, range as CFRange )\nif ( range.length == 0 ) then return NSNotFound\n\nNSInteger i = range.location + range.length / 2\nCFTypeRef midVal = array[i]\n\nselect ( fn NumberCompare( midVal, key ) )\n  case NSOrderedAscending\n    return fn BinarySearch( array, key, fn CFRangeMake( i + 1, range.length - i + 1 ) )\n  case NSOrderedDescending\n    return fn BinarySearch( array, key, fn CFRangeMake( range.location, i - range.location ) )\nend select\nend fn = i\n\nvoid local fn DoIt\n  CFArrayRef a = @[@1, @3, @4, @5, @6, @7, @8, @9, @10]\n  NSLog(@\"6 is at position %d\", fn BinarySearch( a, @6, fn CFRangeMake(0,len(a)) )) // prints 4\nend fn\n\nfn DoIt\n\nHandleEvents",
    "def binSearchI = { aList, target ->\n    def a = aList\n    def offset = 0\n    while (!a.empty) {\n        def n = a.size()\n        def m = n.intdiv(2)\n        if(a[m] > target) {\n            a = a[0..<m]\n        } else if (a[m] < target) {\n            a = a[(m + 1)..<n]\n            offset += m + 1\n        } else {\n            return [index: offset + m]\n        }\n    }\n    return [\"insertion point\": offset]\n}",
    "def a = [] as Set\ndef random = new Random()\nwhile (a.size() < 20) { a << random.nextInt(30) }\ndef source = a.sort()\nsource[0..-2].eachWithIndex { si, i -> assert si < source[i+1] }\n\nprintln \"${source}\"\n.upto(5) {\n    target = random.nextInt(10) + (it - 2) * 10\n    print \"Trial #${it}. Looking for: ${target}\"\n    def answers = [binSearchR, binSearchI].collect { search ->\n        search(source, target)\n    }\n    assert answers[0] == answers[1]\n    println \"\"\"\n    Answer: ${answers[0]}, : ${source[answers[0].values().iterator().next()]}\"\"\"\n}",
    "public class BinarySearchIterative {\n\n    public static int binarySearch(int[] nums, int check) {\n        int hi = nums.length - 1;\n        int lo = 0;\n        while (hi >= lo) {\n            int guess = (lo + hi) >>> 1;  // from OpenJDK\n            if (nums[guess] > check) {\n                hi = guess - 1;\n            } else if (nums[guess] < check) {\n                lo = guess + 1;\n            } else {\n                return guess;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] haystack = {1, 5, 6, 7, 8, 11};\n        int needle = 5;\n        int index = binarySearch(haystack, needle);\n        if (index == -1) {\n            System.out.println(needle + \" is not in the array\");\n        } else {\n            System.out.println(needle + \" is at index \" + index);\n        }\n    }\n}",
    "public class BinarySearchRecursive {\n\n    public static int binarySearch(int[] haystack, int needle, int lo, int hi) {\n        if (hi < lo) {\n            return -1;\n        }\n        int guess = (hi + lo) / 2;\n        if (haystack[guess] > needle) {\n            return binarySearch(haystack, needle, lo, guess - 1);\n        } else if (haystack[guess] < needle) {\n            return binarySearch(haystack, needle, guess + 1, hi);\n        }\n        return guess;\n    }\n\n    public static void main(String[] args) {\n        int[] haystack = {1, 5, 6, 7, 8, 11};\n        int needle = 5;\n\n        int index = binarySearch(haystack, needle, 0, haystack.length);\n\n        if (index == -1) {\n            System.out.println(needle + \" is not in the array\");\n        } else {\n            System.out.println(needle + \" is at index \" + index);\n        }\n    }\n}",
    "function binary_search_recursive(a, value, lo, hi) {\n  if (hi < lo) { return null; }\n\n  var mid = Math.floor((lo + hi) / 2);\n\n  if (a[mid] > value) {\n    return binary_search_recursive(a, value, lo, mid - 1);\n  }\n  if (a[mid] < value) {\n    return binary_search_recursive(a, value, mid + 1, hi);\n  }\n  return mid;\n}",
    "function binary_search_iterative(a, value) {\n  var mid, lo = 0,\n      hi = a.length - 1;\n\n  while (lo <= hi) {\n    mid = Math.floor((lo + hi) / 2);\n\n    if (a[mid] > value) {\n      hi = mid - 1;\n    } else if (a[mid] < value) {\n      lo = mid + 1;\n    } else {\n      return mid;\n    }\n  }\n  return null;\n}",
    "/**\n   Binary search, in Jsish, based on Javascript entry\n   Tectonics: jsish -u -time true -verbose true binarySearch.jsi\n*/\nfunction binarySearchIterative(haystack, needle) {\n    var mid, low = 0, high = haystack.length - 1;\n\n    while (low <= high) {\n        mid = Math.floor((low + high) / 2);\n        if (haystack[mid] > needle) {\n            high = mid - 1;\n        } else if (haystack[mid] < needle) {\n            low = mid + 1;\n        } else {\n            return mid;\n        }\n    }\n    return null;\n}\n\n/* recursive */\nfunction binarySearchRecursive(haystack, needle, low, high) {\n    if (high < low) { return null; }\n\n    var mid = Math.floor((low + high) / 2);\n\n    if (haystack[mid] > needle) {\n        return binarySearchRecursive(haystack, needle, low, mid - 1);\n    }\n    if (haystack[mid] < needle) {\n        return binarySearchRecursive(haystack, needle, mid + 1, high);\n    }\n    return mid;\n}\n\n/* Testing and timing */\nif (Interp.conf('unitTest') > 0) {\n    var arr = [];\n    for (var i = -5000; i <= 5000; i++) { arr.push(i); }\n\n    assert(arr.length == 10001);\n    assert(binarySearchIterative(arr, 0) == 5000);\n    assert(binarySearchRecursive(arr, 0, 0, arr.length - 1) == 5000);\n\n    assert(binarySearchIterative(arr, 5000) == 10000);\n    assert(binarySearchRecursive(arr, -5000, 0, arr.length - 1) == 0);\n\n    assert(binarySearchIterative(arr, -5001) == null);\n\n    puts('--Time 100 passes--');\n    puts('Iterative:', Util.times(function() { binarySearchIterative(arr, 42); }, 100), 'µs');\n    puts('Recursive:', Util.times(function() { binarySearchRecursive(arr, 42, 0, arr.length - 1); }, 100), 'µs');\n}",
    "fun <T : Comparable<T>> Array<T>.iterativeBinarySearch(target: T): Int {\n    var hi = size - 1\n    var lo = 0\n    while (hi >= lo) {\n        val guess = lo + (hi - lo) / 2\n        if (this[guess] > target) hi = guess - 1\n        else if (this[guess] < target) lo = guess + 1\n        else return guess\n    }\n    return -1\n}\n\nfun <T : Comparable<T>> Array<T>.recursiveBinarySearch(target: T, lo: Int, hi: Int): Int {\n    if (hi < lo) return -1\n\n    val guess = (hi + lo) / 2\n\n    return if (this[guess] > target) recursiveBinarySearch(target, lo, guess - 1)\n    else if (this[guess] < target) recursiveBinarySearch(target, guess + 1, hi)\n    else guess\n}\n\nfun main(args: Array<String>) {\n    val a = arrayOf(1, 3, 4, 5, 6, 7, 8, 9, 10)\n    var target = 6\n    var r = a.iterativeBinarySearch(target)\n    println(if (r < 0) \"$target not found\" else \"$target found at index $r\")\n    target = 250\n    r = a.iterativeBinarySearch(target)\n    println(if (r < 0) \"$target not found\" else \"$target found at index $r\")\n\n    target = 6\n    r = a.recursiveBinarySearch(target, 0, a.size)\n    println(if (r < 0) \"$target not found\" else \"$target found at index $r\")\n    target = 250\n    r = a.recursiveBinarySearch(target, 0, a.size)\n    println(if (r < 0) \"$target not found\" else \"$target found at index $r\")\n}",
    "function mid = binarySearchRec(list,value,low,high)\n\n    if( high < low )\n        mid = [];\n        return\n    end\n    \n    mid = floor((low + high)/2);\n    \n    if( list(mid) > value )\n        mid = binarySearchRec(list,value,low,mid-1);\n        return\n    elseif( list(mid) < value )\n        mid = binarySearchRec(list,value,mid+1,high);\n        return\n    else\n        return\n    end\n        \nend",
    "function mid = binarySearchIter(list,value)\n\n    low = 1;\n    high = numel(list) - 1;\n    \n    while( low <= high )\n        mid = floor((low + high)/2);\n    \n        if( list(mid) > value )\n            high = mid - 1;\n        elseif( list(mid) < value )\n        	low = mid + 1;\n        else\n            return\n        end\n    end\n    \n    mid = [];\n            \nend",
    "use Structure;\n\nbundle Default {\n  class BinarySearch {\n    function : Main(args : String[]) ~ Nil {\n      values := [-1, 3, 8, 13, 22];\n      DoBinarySearch(values, 13)->PrintLine();\n      DoBinarySearch(values, 7)->PrintLine();\n    }\n    \n    function : native : DoBinarySearch(values : Int[], value : Int) ~ Int {\n      low := 0;\n      high := values->Size() - 1;\n\n      while(low <= high) {\n        mid := (low + high) / 2;\n        \n        if(values[mid] > value) {\n          high := mid - 1;\n        }\n        else if(values[mid] < value) {\n          low := mid + 1;\n        }\n        else {\n          return mid;\n        };\n      };\n\n      return -1;\n    }\n  }\n}",
    "#import <Foundation/Foundation.h>\n\n@interface NSArray (BinarySearch)\n// Requires all elements of this array to implement a -compare: method which\n// returns a NSComparisonResult for comparison.\n// Returns NSNotFound when not found\n- (NSInteger) binarySearch:(id)key;\n@end\n\n@implementation NSArray (BinarySearch)\n- (NSInteger) binarySearch:(id)key {\n  NSInteger lo = 0;\n  NSInteger hi = [self count] - 1;\n  while (lo <= hi) {\n    NSInteger mid = lo + (hi - lo) / 2;\n    id midVal = self[mid];\n    switch ([midVal compare:key]) {\n    case NSOrderedAscending:\n      lo = mid + 1;\n      break;\n    case NSOrderedDescending:\n      hi = mid - 1;\n      break;\n    case NSOrderedSame:\n      return mid;\n    }\n  }\n  return NSNotFound;\n}\n@end\n\nint main()\n{\n  @autoreleasepool {\n\n    NSArray *a = @[@1, @3, @4, @5, @6, @7, @8, @9, @10];\n    NSLog(@\"6 is at position %d\", [a binarySearch:@6]); // prints 4\n\n  }\n  return 0;\n}",
    "#import <Foundation/Foundation.h>\n\n@interface NSArray (BinarySearchRecursive)\n// Requires all elements of this array to implement a -compare: method which\n// returns a NSComparisonResult for comparison.\n// Returns NSNotFound when not found\n- (NSInteger) binarySearch:(id)key inRange:(NSRange)range;\n@end\n\n@implementation NSArray (BinarySearchRecursive)\n- (NSInteger) binarySearch:(id)key inRange:(NSRange)range {\n  if (range.length == 0)\n    return NSNotFound;\n  NSInteger mid = range.location + range.length / 2;\n  id midVal = self[mid];\n  switch ([midVal compare:key]) {\n  case NSOrderedAscending:\n    return [self binarySearch:key\n                      inRange:NSMakeRange(mid + 1, NSMaxRange(range) - (mid + 1))];\n  case NSOrderedDescending:\n    return [self binarySearch:key\n                      inRange:NSMakeRange(range.location, mid - range.location)];\n  default:\n    return mid;\n  }\n}\n@end\n\nint main()\n{\n  @autoreleasepool {\n\n    NSArray *a = @[@1, @3, @4, @5, @6, @7, @8, @9, @10];\n    NSLog(@\"6 is at position %d\", [a binarySearch:@6]); // prints 4\n\n  }\n  return 0;\n}",
    "#import <Foundation/Foundation.h>\n\nint main()\n{\n  @autoreleasepool {\n\n    NSArray *a = @[@1, @3, @4, @5, @6, @7, @8, @9, @10];\n    NSLog(@\"6 is at position %lu\", [a indexOfObject:@6\n                                      inSortedRange:NSMakeRange(0, [a count])\n                                            options:0\n                                    usingComparator:^(id x, id y){ return [x compare: y]; }]); // prints 4\n\n  }\n  return 0;\n}",
    "#import <Foundation/Foundation.h>\n\nCFComparisonResult myComparator(const void *x, const void *y, void *context) {\n  return [(__bridge id)x compare:(__bridge id)y];\n}\n\nint main(int argc, const char *argv[]) {\n  @autoreleasepool {\n\n    NSArray *a = @[@1, @3, @4, @5, @6, @7, @8, @9, @10];\n    NSLog(@\"6 is at position %ld\", CFArrayBSearchValues((__bridge CFArrayRef)a,\n                                                        CFRangeMake(0, [a count]),\n                                                        (__bridge const void *)@6,\n                                                        myComparator,\n                                                        NULL)); // prints 4\n\n  }\n  return 0;\n}",
    "function i = binsearch_r(array, val, low, high)\n  if ( high < low )\n    i = 0;\n  else\n    mid = floor((low + high) / 2);\n    if ( array(mid) > val )\n      i = binsearch_r(array, val, low, mid-1);\n    elseif ( array(mid) < val ) \n      i = binsearch_r(array, val, mid+1, high);\n    else\n      i = mid;\n    endif\n  endif\nendfunction",
    "function i = binsearch(array, value)\n  low = 1;\n  high = numel(array);\n  i = 0;\n  while ( low <= high )\n    mid = floor((low + high)/2);\n    if (array(mid) > value) \n      high = mid - 1;\n    elseif (array(mid) < value)\n      low = mid + 1;\n    else\n      i = mid;\n      return;\n    endif\n  endwhile\nendfunction",
    "binarysearch(v, x) = {\n    local(\n        minm = 1,\n        maxm = length(v),\n        guess = floor(maxm/2+minm/2)\n    );\n\n    while(v[guess] != x,    \n        if(v[guess] < x, minm = guess + 1, maxm = guess - 1);\n        if(minm > maxm,\n            guess = 0;\n            break\n        );\n        guess = floor(maxm/2+minm/2)\n    );\n\n    return(guess);\n}\n\nidx = binarysearch([1,4,9,16,25,36,49,64,81,100,121,144], 121);\nif(idx, \\\n    print(\"Item exists on index \", idx), \\\n    print(\"Item does not exist anywhere.\") \\\n)",
    "sub binary_search {\n    my ($array_ref, $value, $left, $right) = @_;\n    while ($left <= $right) {\n        my $middle = int(($right + $left) >> 1);\n        if ($value == $array_ref->[$middle]) {\n            return $middle;\n        }\n        elsif ($value < $array_ref->[$middle]) {\n            $right = $middle - 1;\n        }\n        else {\n            $left = $middle + 1;\n        }\n    }\n    return -1;\n}",
    "sub binary_search {\n    my ($array_ref, $value, $left, $right) = @_;\n    return -1 if ($right < $left);\n    my $middle = int(($right + $left) >> 1);\n    if ($value == $array_ref->[$middle]) {\n        return $middle;\n    }\n    elsif ($value < $array_ref->[$middle]) {\n        binary_search($array_ref, $value, $left, $middle - 1);\n    }\n    else {\n        binary_search($array_ref, $value, $middle + 1, $right);\n    }\n}",
    "function binary_search( $array, $secret, $start, $end )\n{\n        do\n        {\n                $guess = (int)($start + ( ( $end - $start ) / 2 ));\n\n                if ( $array[$guess] > $secret )\n                        $end = $guess;\n\n                if ( $array[$guess] < $secret )\n                        $start = $guess;\n\n                if ( $end < $start)\n                        return -1;\n\n        } while ( $array[$guess] != $secret );\n\n        return $guess;\n}",
    "function binary_search( $array, $secret, $start, $end )\n{\n        $guess = (int)($start + ( ( $end - $start ) / 2 ));\n\n        if ( $end < $start)\n                return -1;\n\n        if ( $array[$guess] > $secret )\n                return (binary_search( $array, $secret, $start, $guess ));\n\n        if ( $array[$guess] < $secret )\n                return (binary_search( $array, $secret, $guess, $end ) );\n\n        return $guess;\n}",
    "#include <stdio.h>\ngo =>\n  A = [2, 4, 6, 8, 9],\n  TestValues = [2,1,8,10,9,5],\n\n  foreach(Value in TestValues)\n    test(binary_search,A, Value)\n  end,\n  test(binary_search,[1,20,3,4], 5),\n  nl.\n\n% Test with binary search predicate Search\ntest(Search,A,Value) => \n  Ret = apply(Search,A,Value),\n  printf(\"A: %w Value:%d Ret: %d: \", A, Value, Ret),\n  if Ret == -1 then\n    println(\"The array is not sorted.\")\n  elseif Ret == 0 then\n    printf(\"The value %d is not in the array.\\n\", Value)\n  else\n    printf(\"The value %d is found at position %d.\\n\", Value, Ret)\n  end.\n\nbinary_search(A, Value) = V =>\n  V1 = 0,\n  % we want a sorted array\n  if not sort(A) == A then\n    V1 := -1\n  else \n    Low = 1,\n    High = A.length,\n    Mid = 1,\n    Found = 0,\n    while (Found == 0, Low <= High) \n       Mid := (Low + High) // 2,\n       if A[Mid] > Value then\n         High := Mid - 1\n       elseif A[Mid] < Value then\n         Low := Mid + 1\n       else \n         V1 := Mid,\n         Found := 1\n      end\n    end\n  end,\n  V = V1.",
    "/* A binary search of list A for element M */\nsearch: procedure (A, M) returns (fixed binary);\n   declare (A(*), M) fixed binary;\n   declare (l, r, mid) fixed binary;\n\n   l = lbound(a,1)-1; r = hbound(A,1)+1;\n   do while (l <= r);\n      mid = (l+r)/2;\n      if A(mid) = M then return (mid);\n      if A(mid) < M then\n         L = mid+1;\n      else\n         R = mid-1;\n   end;\n   return (lbound(A,1)-1);\nend search;",
    "function BinarySearch-Iterative ([int[]]$Array, [int]$Value)\n{\n    [int]$low = 0\n    [int]$high = $Array.Count - 1\n\n    while ($low -le $high)\n    {\n        [int]$mid = ($low + $high) / 2\n\n        if ($Array[$mid] -gt $Value)\n        {\n            $high = $mid - 1\n        }\n        elseif ($Array[$mid] -lt $Value)\n        {\n            $low = $mid + 1\n        }\n        else\n        {\n            return $mid\n        }\n    }\n\n    return -1\n}\n\nfunction BinarySearch-Recursive ([int[]]$Array, [int]$Value, [int]$Low = 0, [int]$High = $Array.Count)\n{\n    if ($High -lt $Low)\n    {\n        return -1\n    }\n\n    [int]$mid = ($Low + $High) / 2\n\n    if ($Array[$mid] -gt $Value)\n    {\n        return BinarySearch $Array $Value $Low ($mid - 1)\n    }\n    elseif ($Array[$mid] -lt $Value)\n    {\n        return BinarySearch $Array $Value ($mid + 1) $High\n    }\n    else\n    {\n        return $mid\n    }\n}\n\nfunction Show-SearchResult ([int[]]$Array, [int]$Search, [ValidateSet(\"Iterative\", \"Recursive\")][string]$Function)\n{\n    switch ($Function)\n    {\n        \"Iterative\" {$index = BinarySearch-Iterative -Array $Array -Value $Search}\n        \"Recursive\" {$index = BinarySearch-Recursive -Array $Array -Value $Search}\n    }\n\n    if ($index -ge 0)\n    {\n        Write-Host (\"Using BinarySearch-{0}: {1} is at index {2}\" -f $Function, $numbers[$index], $index)\n    }\n    else\n    {\n        Write-Host (\"Using BinarySearch-{0}: {1} not found\" -f $Function, $Search) -ForegroundColor Red\n    }\n}",
    "BinSearch <- function(A, value, low, high) {\n  if ( high < low ) {\n    return(NULL)\n  } else {\n    mid <- floor((low + high) / 2)\n    if ( A[mid] > value )\n      BinSearch(A, value, low, mid-1)\n    else if ( A[mid] < value )\n      BinSearch(A, value, mid+1, high)\n    else\n      mid\n  }\n}",
    "IterBinSearch <- function(A, value) {\n  low = 1\n  high = length(A)\n  i = 0\n  while ( low <= high ) {\n    mid <- floor((low + high)/2)\n    if ( A[mid] > value )\n      high <- mid - 1\n    else if ( A[mid] < value )\n      low <- mid + 1\n    else\n      return(mid)\n  }\n  NULL\n}",
    "decimals(0)\narray = [7, 14, 21, 28, 35, 42, 49, 56, 63, 70]\n \nfind= 42\nindex = where(array,find,0,len(array))\nif index >= 0 \n   see \"the value \" + find+ \" was found at index \" + index\nelse\n   see \"the value \" + find + \" was not found\"\nok\n\nfunc where(a,s,b,t)\n     h = 2\n     while h<(t-b)\n           h *= 2\n     end\n     h /= 2\n     while h != 0\n           if (b+h)<=t\n              if s>=a[b+h]\n                 b += h\n              ok\n           ok\n           h /= 2\n     end\n     if s=a[b]\n        return b-1\n     else \n        return -1\n     ok",
    "func binary_search(a, i) {\n \n    var l = 0\n    var h = a.end\n \n    while (l <= h) {\n        var mid = (h+l / 2 -> int)\n        a[mid] > i && (h = mid-1; next)\n        a[mid] < i && (l = mid+1; next)\n        return mid\n    }\n \n    return -1\n}",
    "func binary_search(arr, value, low=0, high=arr.end) {\n    high < low && return -1\n    var middle = ((high+low) // 2)\n\n    given (arr[middle]) { |item|\n        case (value < item) {\n            binary_search(arr, value, low, middle-1)\n        }\n        case (value > item) {\n            binary_search(arr, value, middle+1, high)\n        }\n        case (value == item) {\n            middle\n        }\n    }\n}",
    "func testBinarySearch(n: Int) {\n  let odds = Array(stride(from: 1, through: n, by: 2))\n  let result = flatMap(0...n) {binarySearch(odds, $0)}\n  assert(result == Array(0..<odds.count))\n  println(\"\\(odds) are odd natural numbers\")\n  for it in result {\n    println(\"\\(it) is ordinal of \\(odds[it])\")\n  }\n}\n\ntestBinarySearch(12)\n\nfunc flatMap<T, U>(source: [T], transform: (T) -> U?) -> [U] {\n  return source.reduce([]) {(var xs, x) in if let x = transform(x) {xs.append(x)}; return xs}\n}",
    "// Main program for testing BINARY_SEARCH\n#3 = Get_Num(\"Value to search: \")\nEOF\n#2 = Cur_Line                   // hi\n#1 = 1                          // lo\nCall(\"BINARY_SEARCH\")\nMessage(\"Value \") Num_Type(#3, NOCR)\nif (Return_Value < 1) {\n    Message(\" not found\\n\")\n} else {\n    Message(\" found at index \") Num_Type(Return_Value)\n}\nreturn\n\n:BINARY_SEARCH:\nwhile (#1 <= #2) {\n    #12 = (#1 + #2) / 2\n    Goto_Line(#12)\n    #11 = Num_Eval()\n    if (#3 == #11) {\n        return(#12)             // found\n    } else {\n        if (#3 < #11) {\n            #2 = #12-1\n        } else {\n            #1 = #12+1\n        }\n    }\n}\nreturn(0)                       // not found",
    "fn binary_search_rec(a []f64, value f64, low int, high int) int { // recursive\n    if high <= low {\n        return -1\n    }\n    mid := (low + high) / 2\n    if a[mid] > value {\n        return binary_search_rec(a, value, low, mid-1)\n    } else if a[mid] < value {\n        return binary_search_rec(a, value, mid+1, high)\n    }\n    return mid\n}\nfn binary_search_it(a []f64, value f64) int { //iterative\n    mut low := 0\n    mut high := a.len - 1\n    for low <= high {\n        mid := (low + high) / 2\n        if a[mid] > value {\n            high = mid - 1\n        } else if a[mid] < value {\n            low = mid + 1\n        } else {\n            return mid\n        }\n    }\n    return -1\n}\nfn main() {\n    f_list := [1.2,1.5,2,5,5.13,5.4,5.89,9,10]\n    println(binary_search_rec(f_list,9,0,f_list.len))\n    println(binary_search_rec(f_list,15,0,f_list.len))\n\n    println(binary_search_it(f_list,9))\n    println(binary_search_it(f_list,15))\n}",
    "class BinarySearch {\n    static recursive(a, value, low, high) {\n        if (high < low) return -1\n        var mid = low + ((high - low)/2).floor\n        if (a[mid] > value) return recursive(a, value, low, mid-1)\n        if (a[mid] < value) return recursive(a, value, mid+1, high)\n        return mid\n    }\n\n    static iterative(a, value) {\n        var low = 0\n        var high = a.count - 1\n        while (low <= high) {\n            var mid = low + ((high - low)/2).floor\n            if (a[mid] > value) {\n                high = mid - 1\n            } else if (a[mid] < value) {\n                low = mid + 1\n            } else {\n                return mid\n            }\n        }\n        return -1\n    }\n}\n\nvar a = [10, 22, 45, 67, 89, 97]\nSystem.print(\"array = %(a)\")\n\nSystem.print(\"\\nUsing the recursive algorithm:\")\nfor (value in [67, 93]) {\n    var index = BinarySearch.recursive(a, value, 0, a.count - 1)\n    if (index >= 0) {\n        System.print(\"  %(value) was found at index %(index) of the array.\")\n    } else {\n        System.print(\"  %(value) was not found in the array.\")\n    }\n}\n\nSystem.print(\"\\nUsing the iterative algorithm:\")\nfor (value in [22, 70]) {\n    var index = BinarySearch.iterative(a, value)\n    if (index >= 0) {\n        System.print(\"  %(value) was found at index %(index) of the array.\")\n    } else {\n        System.print(\"  %(value) was not found in the array.\")\n    }\n}",
    "*        Binary search             \nBINSRCH  LA    R5,TABLE            Begin of table\n         SR    R2,R2               low  = 0                                 \n         LA    R3,ENTRIES-1        high = N-1\nLOOP     CR    R2,R3               while (low <= high)                 \n         JH    NOTFOUND            {                                   \n         ARK   R4,R2,R3               mid = low + high                 \n         SRL   R4,1                   mid = mid / 2\n         LA    R1,1(R4)               mid + 1\n         AHIK  R0,R4,-1               mid - 1\n         MSFI  R4,ENTRYL              mid * length                     \n         AR    R4,R5                  Table[mid]                       \n         CLC   0(L'KEY,R4),SEARCH     Compare \n         JE    FOUND                  Equal? => Found                \n         LOCRH R3,R0                  High?  => HIGH = MID-1           \n         LOCRL R2,R1                  Low?   => LOW  = MID+1           \n         J     LOOP                }",
    "pub fn binarySearch(comptime T: type, input: []const T, search_value: T) ?usize {\n    if (input.len == 0) return null;\n    if (@sizeOf(T) == 0) return 0;\n\n    var view: []const T = input;\n    const item_ptr: *const T = item_ptr: while (view.len > 0) {\n        const mid = (view.len - 1) / 2;\n        const mid_elem_ptr: *const T = &view[mid];\n\n        if (mid_elem_ptr.* > search_value)\n            view = view[0..mid]\n        else if (mid_elem_ptr.* < search_value)\n            view = view[mid + 1 .. view.len]\n        else\n            break :item_ptr mid_elem_ptr;\n    } else return null;\n\n    const distance_in_bytes = @intFromPtr(item_ptr) - @intFromPtr(input.ptr);\n    return (distance_in_bytes / @sizeOf(T));\n}",
    "pub fn binarySearch(comptime T: type, input: []const T, search_value: T) ?usize {\n    return binarySearchInner(T, input, search_value, @intFromPtr(input.ptr));\n}\n\nfn binarySearchInner(comptime T: type, input: []const T, search_value: T, start_address: usize) ?usize {\n    if (input.len == 0) return null;\n    if (@sizeOf(T) == 0) return 0;\n\n    const mid = (input.len - 1) / 2;\n    const mid_elem_ptr: *const T = &input[mid];\n\n    return if (mid_elem_ptr.* > search_value)\n        binarySearchInner(T, input[0..mid], search_value, start_address)\n    else if (mid_elem_ptr.* < search_value)\n        binarySearchInner(T, input[mid + 1 .. input.len], search_value, start_address)\n    else\n        (@intFromPtr(mid_elem_ptr) - start_address) / @sizeOf(T);\n}",
    "const math = @import(\"std\").math;\n\npub fn binarySearch(comptime T: type, input: []const T, search_value: T) ?usize {\n    if (input.len == 0) return null;\n    if (@sizeOf(T) == 0) return 0;\n\n    var low: usize = 0;\n    var high: usize = input.len - 1;\n    return while (low <= high) {\n        const mid = ((high - low) / 2) + low;\n        const mid_elem: T = input[mid];\n        if (mid_elem > search_value)\n            high = math.sub(usize, mid, 1) catch break null\n        else if (mid_elem < search_value)\n            low = mid + 1\n        else\n            break mid;\n    } else null;\n}",
    "const math = @import(\"std\").math;\n\npub fn binarySearch(comptime T: type, input: []const T, search_value: T) ?usize {\n    if (input.len == 0) return null;\n    if (@sizeOf(T) == 0) return 0;\n\n    return binarySearchInner(T, input, search_value, 0, input.len - 1);\n}\n\nfn binarySearchInner(comptime T: type, input: []const T, search_value: T, low: usize, high: usize) ?usize {\n    if (low > high) return null;\n\n    const mid = ((high - low) / 2) + low;\n    const mid_elem: T = input[mid];\n\n    return if (mid_elem > search_value)\n        binarySearchInner(T, input, search_value, low, math.sub(usize, mid, 1) catch return null)\n    else if (mid_elem < search_value)\n        binarySearchInner(T, input, search_value, mid + 1, high)\n    else\n        mid;\n}",
    "(defun fast-fib-r (n a b)\n   (if (or (zp n) (zp (1- n)))\n       b\n       (fast-fib-r (1- n) b (+ a b))))\n\n(defun fast-fib (n)\n   (fast-fib-r n 1 1))\n\n(defun first-fibs-r (n i)\n   (declare (xargs :measure (nfix (- n i))))\n   (if (zp (- n i))\n       nil\n       (cons (fast-fib i)\n             (first-fibs-r n (1+ i)))))\n\n(defun first-fibs (n)\n   (first-fibs-r n 0))",
    "integer\nfibs(integer n)\n{\n    integer w;\n\n    if (n == 0) {\n        w = 0;\n    } elif (n == 1) {\n        w = 1;\n    } else {\n        integer a, b, i;\n\n        i = 1;\n        a = 0;\n        b = 1;\n        while (i < n) {\n            w = a + b;\n            a = b;\n            b = w;\n            i += 1;\n        }\n    }\n\n    return w;\n}",
    "#include <hbasic.h>\n\n#define TERM1    1.61803398874989\n#define TERM2    -0.61803398874989\n\n#context get Fibonacci number with analitic mode\n  GetArgs(n) \n  get Inv of (M_SQRT5), Mul by( Pow (TERM 1, n), Minus( Pow(TERM 2, n) )  );\n  then Return\\\\\n\n#proto fibonacci_recursive(__X__)\n#synon _fibonacci_recursive    getFibonaccinumberwithrecursivemodeof\n\n#proto fibonacci_iterative(__X__)\n#synon _fibonacci_iterative    getFibonaccinumberwithiterativemodeof\n\nBegin\n  Option Stack 1024\n\n  get Arg Number(2, n), and Take( n );\n  then, get Fibonacci number with analitic mode, and Print It with a Newl.\n  secondly, get Fibonacci number with recursive mode of(n), and Print It with a Newl.\n  finally, get Fibonacci number with iterative mode of (n), and Print It with a Newl.\nEnd\n\nSubrutines\n\nfibonacci_recursive(n)\n   Iif ( var(n) Is Le? (2), 1 , \\\n         get Fibonacci number with recursive mode of( var(n) Minus (1));\\\n         get Fibonacci number with recursive mode of( var(n) Minus (2)); and Add It )\nReturn\n\nfibonacci_iterative(n)\n  A=0\n  B=1\n  For Up( I:=2, n, 1 )\n    C=B\n    Let ( B: = var(A) Plus (B) )\n    A=C\n  Next\nReturn(B)",
    "/*\n author: snugsfbay\n date: March 3, 2016\n description: Create a list of x numbers in the Fibonacci sequence.\n     - user may specify the length of the list \n     - enforces a minimum of 2 numbers in the sequence because any fewer is not a sequence\n     - enforces a maximum of 47 because further values are too large for integer data type \n     - Fibonacci sequence always starts with 0 and 1 by definition\n*/\npublic class FibNumbers{\n\nfinal static Integer MIN = 2; //minimum length of sequence\nfinal static Integer MAX = 47; //maximum length of sequence\n\n/* \n  description: method to create a list of numbers in the Fibonacci sequence \n  param: user specified integer representing length of sequence should be 2-47, inclusive.\n      - Sequence starts with 0 and 1 by definition so the minimum length could be as low as 2.\n      - For 48th number in sequence or greater, code would require a Long data type rather than an Integer.\n  return: list of integers in sequence.\n*/\npublic static List<Integer> makeSeq(Integer len){\n\n  List<Integer> fib = new List<Integer>{0,1}; // initialize list with first two values\n  Integer i;\n  \n  if(len<MIN || len==null || len>MAX) {\n      if (len>MAX){\n          len=MAX; //set length to maximum if user entered too high a value\n      }else{\n          len=MIN; //set length to minimum if user entered too low a value or none\n      }\n  } //This could be refactored using teneray operator, but we want code coverage to be reflected for each condition\n  \n  //start with initial list size to find previous two values in the sequence, continue incrementing until list reaches user defined length\n  for(i=fib.size(); i<len; i++){ \n    fib.add(fib[i-1]+fib[i-2]); //create new number based on previous numbers and add that to the list\n  }\n\n  return fib; \n  }\n  \n}",
    "(*\n** This implementation is verified!\n*)\n\ndataprop FIB (int, int) =\n  | FIB0 (0, 0) | FIB1 (1, 1)\n  | {n:nat} {r0,r1:int} FIB2 (n+2, r0+r1) of (FIB (n, r0), FIB (n+1, r1))\n// end of [FIB] // end of [dataprop]\n\nfun\nfibats{n:nat}\n  (n: int (n))\n: [r:int] (FIB (n, r) | int r) = let\n  fun loop\n    {i:nat | i <= n}{r0,r1:int}\n  (\n    pf0: FIB (i, r0), pf1: FIB (i+1, r1)\n  | ni: int (n-i), r0: int r0, r1: int r1\n  ) : [r:int] (FIB (n, r) | int r) =\n    if (ni > 0)\n      then loop{i+1}(pf1, FIB2 (pf0, pf1) | ni - 1, r1, r0 + r1)\n      else (pf0 | r0)\n    // end of [if]\n  // end of [loop]\nin\n  loop {0} (FIB0 (), FIB1 () | n, 0, 1)\nend // end of [fibats]",
    "Loop, 5\n  MsgBox % fib(A_Index)\nReturn\n\nfib(n)\n{\n  If (n < 2) \n    Return n\n  i := last := this := 1\n  While (i <= n)\n  {\n    new := last + this\n    last := this\n    this := new\n    i++\n  }\n  Return this\n}",
    "#! /usr/bin/bc -q\n\ndefine fib(x) {\n    if (x <= 0) return 0;\n    if (x == 1) return 1;\n\n    a = 0;\n    b = 1;\n    for (i = 1; i < x; i++) {\n        c = a+b; a = b; b = c;\n    }\n    return c;\n}\nfib(1000)\nquit",
    "#include <stdio.h>\ntypedef enum{false=0, true=!0} bool;\ntypedef void iterator;\n\n#include <setjmp.h>\n/* declare label otherwise it is not visible in sub-scope */\n#define LABEL(label) jmp_buf label; if(setjmp(label))goto label;\n#define GOTO(label) longjmp(label, true)\n\n/* the following line is the only time I have ever required \"auto\" */\n#define FOR(i, iterator) { auto bool lambda(i); yield_init = (void *)&lambda; iterator; bool lambda(i)\n#define DO {\n#define     YIELD(x) if(!yield(x))return\n#define     BREAK    return false\n#define     CONTINUE return true\n#define OD CONTINUE; } }\n\nstatic volatile void *yield_init; /* not thread safe */\n#define YIELDS(type) bool (*yield)(type) = yield_init\n\niterator fibonacci(int stop){\n    YIELDS(int);\n    int f[] = {0, 1};\n    int i;\n    for(i=0; i<stop; i++){\n        YIELD(f[i%2]);\n        f[i%2]=f[0]+f[1];\n    }\n}\n\nmain(){\n  printf(\"fibonacci: \");\n  FOR(int i, fibonacci(16)) DO\n    printf(\"%d, \",i);\n  OD;\n  printf(\"...\\n\");\n}",
    "#include <stdlib.h>\n#include <stdio.h>\n#include <gmp.h>\n\ntypedef struct node node;\nstruct node {\n	int n;\n	mpz_t v;\n	node *next;\n};\n\n#define CSIZE 37\nnode *cache[CSIZE];\n\n// very primitive linked hash table\nnode * find_cache(int n)\n{\n	int idx = n % CSIZE;\n	node *p;\n\n	for (p = cache[idx]; p && p->n != n; p = p->next);\n	if (p) return p;\n\n	p = malloc(sizeof(node));\n	p->next = cache[idx];\n	cache[idx] = p;\n\n	if (n < 2) {\n		p->n = n;\n		mpz_init_set_ui(p->v, 1);\n	} else {\n		p->n = -1; // -1: value not computed yet\n		mpz_init(p->v);\n	}\n	return p;\n}\n\nmpz_t tmp1, tmp2;\nmpz_t *fib(int n)\n{\n	int x;\n	node *p = find_cache(n);\n\n	if (p->n < 0) {\n		p->n = n;\n		x = n / 2;\n\n		mpz_mul(tmp1, *fib(x-1), *fib(n - x - 1));\n		mpz_mul(tmp2, *fib(x), *fib(n - x));\n		mpz_add(p->v, tmp1, tmp2);\n	}\n	return &p->v;\n}\n\nint main(int argc, char **argv)\n{\n	int i, n;\n	if (argc < 2) return 1;\n\n	mpz_init(tmp1);\n	mpz_init(tmp2);\n\n	for (i = 1; i < argc; i++) {\n		n = atoi(argv[i]);\n		if (n < 0) {\n			printf(\"bad input: %s\\n\", argv[i]);\n			continue;\n		}\n\n		// about 75% of time is spent in printing\n		gmp_printf(\"%Zd\\n\", *fib(n));\n	}\n	return 0;\n}",
    "public static ulong Fib(uint x) {\n    if (x == 0) return 0;\n\n    ulong prev = 0;\n    ulong next = 1;\n    for (int i = 1; i < x; i++)\n    {\n        ulong sum = prev + next;\n        prev = next;\n        next = sum;\n    }\n    return next;\n}",
    "public static IEnumerable<long> Fibs(uint x) {\n    IList<ulong> fibs = new List<ulong>();\n\n    ulong prev = -1;\n    ulong next = 1;\n    for (int i = 0; i < x; i++)\n    {\n     long sum = prev + next;\n        prev = next;\n        next = sum;\n        fibs.Add(sum); \n    }\n    return fibs;\n}",
    "static decimal Sqrt_dec(decimal x, decimal g) { decimal t, lg;\n    do { t = x / g; lg = g; g = (t + g) / 2M; } while (lg != g);\n    return g; }\n\nstatic decimal Pow_dec (decimal bas, uint exp) {\n    if (exp == 0) return 1M;\n    decimal tmp = Pow_dec(bas, exp >> 1); tmp *= tmp;\n    if ((exp & 1) == 1) tmp *= bas; return tmp; }\n\nstatic decimal r5 = Sqrt_dec(5.0M, (decimal)Math.Sqrt(5.0)),\n               Phi = (r5 + 1.0M) / 2.0M;\n\nstatic ulong fib(uint n) {\n    if (n > 93) throw new ArgumentOutOfRangeException(\"n\", n, \"Needs to be smaller than 94.\"); \n    decimal r = Pow_dec(Phi, n) / r5; \n    return (ulong)(n < 64 ? Math.Round(r) : Math.Floor(r)); }",
    "static decimal Sqrt_dec(decimal x, decimal g) { decimal t, lg;\n    do { t = x / g; lg = g; g = (t + g) / 2M; } while (lg != g);\n    return g; }\n\nstatic decimal Pow_dec (decimal bas, uint exp) {\n    if (exp == 0) return 1M;\n    decimal tmp = Pow_dec(bas, exp >> 1); tmp *= tmp;\n    if ((exp & 1) == 1) tmp *= bas; return tmp; }\n\nstatic decimal r5 = Sqrt_dec(5.0M, (decimal)Math.Sqrt(5.0)),\n               Phi = (r5 + 1.0M) / 2.0M;\n\nstatic decimal fib(uint n) {\n    if (n > 128) throw new ArgumentOutOfRangeException(\"n\", n, \"Needs to be smaller than 129.\"); \n    decimal r = Pow_dec(Phi, n) / r5; \n    return n < 64 ? Math.Round(r) : Math.Floor(r); }",
    "private static Matrix M;\nprivate static readonly Matrix N = new Matrix(1,1,1,0);\n\npublic static ulong Fib(uint n) {\n    M = new Matrix(1,0,0,1);\n    MatrixPow(n-1);\n    return (ulong)M[0][0];\n}\n\nprivate static void MatrixPow(double n){\n    if (n > 1) {\n        MatrixPow(n/2);\n        M *= M;\n    }\n    if (n % 2 == 0) M *= N;\n}",
    "private static int[] fibs = new int[]{ -1836311903, 1134903170, \n  -701408733, 433494437, -267914296, 165580141, -102334155, \n  63245986, -39088169, 24157817, -14930352, 9227465, -5702887, \n  3524578, -2178309, 1346269, -832040, 514229, -317811, 196418, \n  -121393, 75025, -46368, 28657, -17711, 10946, -6765, 4181, \n  -2584, 1597, -987, 610, -377, 233, -144, 89, -55, 34, -21, 13, \n  -8, 5, -3, 2, -1, 1, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \n  144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711,\n  28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040,\n  1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817,\n  39088169, 63245986, 102334155, 165580141, 267914296, 433494437,\n  701408733, 1134903170, 1836311903};\n\npublic static int Fib(int n) {\n    if(n < -46 || n > 46) throw new ArgumentOutOfRangeException(\"n\", n, \"Has to be between -46 and 47.\")\n    return fibs[n+46];\n}",
    "using System;\nusing System.Collections.Generic;\nusing BI = System.Numerics.BigInteger;\n \nclass Program\n{\n    // A sparse array of values calculated along the way\n    static SortedList<int, BI> sl = new SortedList<int, BI>();\n \n    // This routine is semi-recursive, but doesn't need to evaluate every number up to n.\n    // Algorithm from here: http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/fibFormula.html#section3\n    static BI Fsl(int n)\n    {\n        if (n < 2) return n;\n        int n2 = n >> 1, pm = n2 + ((n & 1) << 1) - 1; IfNec(n2); IfNec(pm);\n        return n2 > pm ? (2 * sl[pm] + sl[n2]) * sl[n2] : sqr(sl[n2]) + sqr(sl[pm]);\n        // Helper routine for Fsl(). It adds an entry to the sorted list when necessary\n        void IfNec(int x) { if (!sl.ContainsKey(x)) sl.Add(x, Fsl(x)); }\n        // Helper function to square a BigInteger\n        BI sqr(BI x) { return x * x; }\n    }\n \n    // Conventional iteration method (not used here)\n    public static BI Fm(BI n)\n    {\n        if (n < 2) return n; BI cur = 0, pre = 1;\n        for (int i = 0; i <= n - 1; i++) { BI sum = cur + pre; pre = cur; cur = sum; }\n        return cur;\n    }\n \n    public static void Main()\n    {\n        int num = 2_000_000, digs = 35, vlen;\n        var sw = System.Diagnostics.Stopwatch.StartNew(); var v = Fsl(num); sw.Stop();\n        Console.Write(\"{0:n3} ms to calculate the {1:n0}th Fibonacci number, \",\n          sw.Elapsed.TotalMilliseconds, num);\n        Console.WriteLine(\"number of digits is {0}\", vlen = (int)Math.Ceiling(BI.Log10(v)));\n        if (vlen < 10000) {\n            sw.Restart(); Console.WriteLine(v); sw.Stop();\n            Console.WriteLine(\"{0:n3} ms to write it to the console.\", sw.Elapsed.TotalMilliseconds);\n        } else\n            Console.Write(\"partial: {0}...{1}\", v / BI.Pow(10, vlen - digs), v % BI.Pow(10, digs));\n    }\n}",
    "using System;\nusing BI = System.Numerics.BigInteger;\n\nclass Program {\n  \n  // returns the nth Fibonacci number without calculating 0..n-1\n  static BI oneFib(int n) {\n    BI z = (BI)1 << ++n;\n    return BI.ModPow(z, n, (z << n) - z - 1) % z;\n  }\n\n  // returns an array of Fibonacci numbers from the 0th to the nth\n  static BI[] fibTab(int n) {\n    var res = new BI[++n];\n    BI z = (BI)1 << 1, zz = z << 1;\n    for (int i = 0; i < n; ) {\n      res[i] = BI.ModPow(z, ++i, zz - z - 1) % z;\n      z <<= 1; zz <<= 2;\n    }\n    return res;\n  }\n  \n  static void Main(string[] args) {\n    int n = 20;\n    Console.WriteLine(\"Fibonacci numbers 0..{0}: {1}\", n, string.Join(\" \",fibTab(n)));\n    n = 1000;\n    Console.WriteLine(\"Fibonacci({0}): {1}\", n, oneFib(n));\n  }\n}",
    "#include <iostream>\n\nint main()\n{\n        unsigned int a = 1, b = 1;\n        unsigned int target = 48;\n        for(unsigned int n = 3; n <= target; ++n)\n        {\n                unsigned int fib = a + b;\n                std::cout << \"F(\"<< n << \") = \" << fib << std::endl;\n                a = b;\n                b = fib;\n        }\n\n        return 0;\n}",
    "#include <iostream>\n#include <gmpxx.h>\n\nint main()\n{\n        mpz_class a = mpz_class(1), b = mpz_class(1);\n        mpz_class target = mpz_class(100);\n        for(mpz_class n = mpz_class(3); n <= target; ++n)\n        {\n                mpz_class fib = b + a;\n                if ( fib < b )\n                {\n                        std::cout << \"Overflow at \" << n << std::endl;\n                        break;\n                }\n                std::cout << \"F(\"<< n << \") = \" << fib << std::endl;\n                a = b;\n                b = fib;\n        }\n        return 0;\n}",
    "#include <algorithm>\n#include <vector>\n#include <functional>\n#include <iostream>\n \nunsigned int fibonacci(unsigned int n) {\n  if (n == 0) return 0;\n  std::vector<int> v(n+1);\n  v[1] = 1;\n  transform(v.begin(), v.end()-2, v.begin()+1, v.begin()+2, std::plus<int>());\n  // \"v\" now contains the Fibonacci sequence from 0 up\n  return v[n];\n}",
    "#include <iostream>\n\ntemplate <int n> struct fibo\n{\n    enum {value=fibo<n-1>::value+fibo<n-2>::value};\n};\n \ntemplate <> struct fibo<0>\n{\n    enum {value=0};\n};\n\ntemplate <> struct fibo<1>\n{\n    enum {value=1};\n};\n\nint main(int argc, char const *argv[])\n{\n    std::cout<<fibo<12>::value<<std::endl;\n    std::cout<<fibo<46>::value<<std::endl;\n    return 0;\n}",
    "#include <iostream>\n\ninline void fibmul(int* f, int* g)\n{\n  int tmp = f[0]*g[0] + f[1]*g[1];\n  f[1] = f[0]*g[1] + f[1]*(g[0] + g[1]);\n  f[0] = tmp;\n}\n\nint fibonacci(int n)\n{\n  int f[] = { 1, 0 };\n  int g[] = { 0, 1 };\n  while (n > 0)\n  {\n    if (n & 1) // n odd\n    {\n      fibmul(f, g);\n      --n;\n    }\n    else\n    {\n      fibmul(g, g);\n      n >>= 1;\n    }\n  }\n  return f[1];\n}\n\nint main()\n{\n  for (int i = 0; i < 20; ++i)\n    std::cout << fibonacci(i) << \" \";\n  std::cout << std::endl;\n}",
    "// Use Zeckendorf numbers to display Fibonacci sequence.\n// Nigel Galloway October 23rd., 2012\nint main(void) {\n  char NG[22] = {'1',0};\n  int x = -1;\n  N G;\n  for (int fibs = 1; fibs <= 20; fibs++) {\n   for (;G <= N(NG); ++G) x++;\n   NG[fibs] = '0';\n   NG[fibs+1] = 0;\n   std::cout << x << \" \";\n  }\n  std::cout << std::endl;\n  return 0;\n}",
    ";; max is which fib number you'd like computed (0th, 1st, 2nd, etc.)\n;; n is which fib number you're on for this call (0th, 1st, 2nd, etc.)\n;; j is the nth fib number (ex. when n = 5, j = 5)\n;; i is the nth - 1 fib number\n(defn- fib-iter\n  [max n i j]\n  (if (= n max)\n    j\n    (recur max\n           (inc n)\n           j\n           (+ i j))))\n\n(defn fib\n  [max]\n  (if (< max 2)\n    max\n    (fib-iter max 1 0N 1N)))",
    "set_property(GLOBAL PROPERTY fibonacci_0 0)\nset_property(GLOBAL PROPERTY fibonacci_1 1)\nset_property(GLOBAL PROPERTY fibonacci_next 2)\n\n# var = nth number in Fibonacci sequence.\nfunction(fibonacci var n)\n  # If the sequence is too short, compute more Fibonacci numbers.\n  get_property(next GLOBAL PROPERTY fibonacci_next)\n  if(NOT next GREATER ${n})\n    # a, b = last 2 Fibonacci numbers\n    math(EXPR i \"${next} - 2\")\n    get_property(a GLOBAL PROPERTY fibonacci_${i})\n    math(EXPR i \"${next} - 1\")\n    get_property(b GLOBAL PROPERTY fibonacci_${i})\n\n    while(NOT next GREATER ${n})\n      math(EXPR i \"${a} + ${b}\")  # i = next Fibonacci number\n      set_property(GLOBAL PROPERTY fibonacci_${next} ${i})\n      set(a ${b})\n      set(b ${i})\n      math(EXPR next \"${next} + 1\")\n    endwhile()\n    set_property(GLOBAL PROPERTY fibonacci_next ${next})\n  endif()\n\n  get_property(answer GLOBAL PROPERTY fibonacci_${n})\n  set(${var} ${answer} PARENT_SCOPE)\nendfunction(fibonacci)",
    ";; Project : Fibonacci sequence\n\n(defun fibonacci (nr)\n           (cond ((= nr 0) 1)\n           ((= nr 1) 1)\n           (t (+ (fibonacci (- nr 1))\n           (fibonacci (- nr 2))))))\n(format t \"~a\" \"First 10 Fibonacci numbers\") \n(dotimes (n 10) \n(if (< n 1) (terpri))\n(if (< n 9) (format t \"~a\" \" \"))\n(write(+ n 1)) (format t \"~a\" \": \")\n(write (fibonacci n)) (terpri))",
    "(defparameter *fibo-start* '(1 1)) ; elements 1 and 2\n\n;;; Helper functions\n(defun grow-fibo (fibo)\n    (cons (+ (first fibo) (second fibo)) fibo))\n\n(defun generate-fibo (fibo n) ; n must be > 1\n    (if (equal (list-length fibo) n)\n        fibo\n        (generate-fibo (grow-fibo fibo)  n)))\n\n;;; User functions\n(defun fibo (n)\n    (cond ((= n 0) 0)\n          ((= (abs n) 1) 1)\n          (t (let ((result (first (generate-fibo *fibo-start* (abs n)))))\n               (if (and (< n -1) (evenp n))\n                 (- result)\n                 result)))))\n\n(defun fibo-list (n)\n    (cond ((< n 1) nil)\n          ((= n 1) '(1))\n          (t (reverse (generate-fibo *fibo-start* n)))))\n\n(defun fibo-range (lower upper)\n   (if (<= upper lower)\n     nil\n     (reverse (generate-fibo\n                 (list\n                    (fibo (1+ lower))\n                    (fibo  lower))\n                 (1+ (- upper lower))))))",
    "import std.stdio, std.conv, std.algorithm, std.math;\n\nlong sgn(alias unsignedFib)(int n) { // break sign manipulation apart\n    immutable uint m = (n >= 0) ? n : -n;\n    if (n < 0 && (n % 2 == 0))\n        return -unsignedFib(m);\n    else\n        return unsignedFib(m);\n}\n\nlong fibD(uint m) { // Direct Calculation, correct for abs(m) <= 84\n    enum sqrt5r =  1.0L / sqrt(5.0L);         //  1 / sqrt(5)\n    enum golden = (1.0L + sqrt(5.0L)) / 2.0L; // (1 + sqrt(5)) / 2\n    return roundTo!long(pow(golden, m) * sqrt5r);\n}\n\nlong fibI(in uint m) pure nothrow { // Iterative\n    long thisFib = 0;\n    long nextFib = 1;\n    foreach (i; 0 .. m) {\n        long tmp = nextFib;\n        nextFib += thisFib;\n        thisFib  = tmp;\n    }\n    return thisFib;\n}\n\nlong fibR(uint m) { // Recursive\n    return (m < 2) ? m : fibR(m - 1) + fibR(m - 2);\n}\n\nlong fibM(uint m) { // memoized Recursive\n    static long[] fib = [0, 1];\n    while (m >= fib.length )\n        fib ~= fibM(m - 2) + fibM(m - 1);\n    return fib[m];\n}\n\nalias sgn!fibD sfibD;\nalias sgn!fibI sfibI;\nalias sgn!fibR sfibR;\nalias sgn!fibM sfibM;\n\nauto fibG(in int m) { // generator(?)\n    immutable int sign = (m < 0) ? -1 : 1;\n    long yield;\n    \n    return new class {\n        final int opApply(int delegate(ref int, ref long) dg) {\n            int idx = -sign; // prepare for pre-increment\n            foreach (f; this)\n                if (dg(idx += sign, f))\n                    break;\n            return 0;\n        }\n        \n        final int opApply(int delegate(ref long) dg) {\n            long f0, f1 = 1;\n            foreach (p; 0 .. m * sign + 1) {\n                if (sign == -1 && (p % 2 == 0))\n                    yield = -f0;\n                else\n                    yield = f0;\n                if (dg(yield)) break;\n                auto temp = f1;\n                f1 = f0 + f1;\n                f0 = temp;\n            }\n            return 0;\n        }\n    };\n}\n\nvoid main(in string[] args) {\n    int k = args.length > 1 ? to!int(args[1]) : 10;\n    writefln(\"Fib(%3d) = \", k);\n    writefln(\"D : %20d <- %20d + %20d\",\n             sfibD(k), sfibD(k - 1), sfibD(k - 2));\n    writefln(\"I : %20d <- %20d + %20d\",\n             sfibI(k), sfibI(k - 1), sfibI(k - 2));\n    if (abs(k) < 36 || args.length > 2)\n        // set a limit for recursive version\n        writefln(\"R : %20d <- %20d + %20d\",\n                 sfibR(k), sfibM(k - 1), sfibM(k - 2));\n    writefln(\"O : %20d <- %20d + %20d\",\n             sfibM(k), sfibM(k - 1), sfibM(k - 2));\n    foreach (i, f; fibG(-9))\n        writef(\"%d:%d | \", i, f);\n}",
    "import std.bigint;\n\nT fibonacciMatrix(T=BigInt)(size_t n) {\n    int[size_t.sizeof * 8] binDigits;\n    size_t nBinDigits;\n    while (n > 0) {\n        binDigits[nBinDigits] = n % 2;\n        n /= 2;\n        nBinDigits++;\n    }\n\n    T x=1, y, z=1;\n    foreach_reverse (b; binDigits[0 .. nBinDigits]) {\n        if (b) {\n            x = (x + z) * y;\n            y = y ^^ 2 + z ^^ 2;\n        } else {\n            auto x_old = x;\n            x = x ^^ 2 + y ^^ 2;\n            y = (x_old + z) * y;\n        }\n        z = x + y;\n    }\n\n    return y;\n}\n\nvoid main() {\n    10_000_000.fibonacciMatrix;\n}",
    "import std.bigint, std.math;\n\n// Algorithm from: Takahashi, Daisuke,\n// \"A fast algorithm for computing large Fibonacci numbers\".\n// Information Processing Letters 75.6 (30 November 2000): 243-246.\n// Implementation from:\n// pythonista.wordpress.com/2008/07/03/pure-python-fibonacci-numbers\nBigInt fibonacci(in ulong n)\nin {\n    assert(n > 0, \"fibonacci(n): n must be > 0.\");\n} body {\n    if (n <= 2)\n        return 1.BigInt;\n    BigInt F = 1;\n    BigInt L = 1;\n    int sign = -1;\n    immutable uint n2 = cast(uint)n.log2.floor;\n    auto mask = 2.BigInt ^^ (n2 - 1);\n    foreach (immutable i; 1 .. n2) {\n        auto temp = F ^^ 2;\n        F = (F + L) / 2;\n        F = 2 * F ^^ 2 - 3 * temp - 2 * sign;\n        L = 5 * temp + 2 * sign;\n        sign = 1;\n        if (n & mask) {\n            temp = F;\n            F = (F + L) / 2;\n            L = F + 2 * temp;\n            sign = -1;\n        }\n        mask /= 2;\n    }\n    if ((n & mask) == 0) {\n        F *= L;\n    } else {\n        F = (F + L) / 2;\n        F = F * L - sign;\n    }\n    return F;\n}\n\nvoid main() {\n    10_000_000.fibonacci;\n}",
    "int fib(int n) {\n  if (n==0 || n==1) {\n    return n;\n  }\n  var prev=1;\n  var current=1;\n  for (var i=2; i<n; i++) {\n    var next = prev + current;\n    prev = current;\n    current = next;    \n  }\n  return current;\n}\n\nint fibRec(int n) => n==0 || n==1 ? n : fibRec(n-1) + fibRec(n-2);\n\nmain() {\n  print(fib(11));\n  print(fibRec(11));\n}",
    "Iterable<int> fibonacci(int n) sync* {\n  int a = 1, b = 1;\n\n  for (int i = 0; i < n; i++) {\n    yield a;\n\n    int temp = a;\n    a = b;\n    b = temp + b;\n  }\n}\n\nvoid main() => print(fibonacci(20));",
    "Iterable<int> fibonacci() sync* {\n  int a = 1, b = 1;\n\n  while (true) {\n    yield a;\n\n    int temp = a;\n    a = b;\n    b = temp + b;\n  }\n}\n\nvoid main() => print(fibonacci().take(20));",
    "function fib(n: Int64): Int64;\n\n  type TFibMat = array[0..1] of array[0..1] of Int64;\n	\n  function FibMatMul(a,b: TFibMat): TFibMat;\n  var i,j,k: integer;\n      tmp: TFibMat;\n  begin\n    for i := 0 to 1 do\n      for j := 0 to 1 do\n      begin\n	tmp[i,j] := 0;\n	for k := 0 to 1 do tmp[i,j] := tmp[i,j] + a[i,k] * b[k,j];\n      end;\n    FibMatMul := tmp;\n  end;\n	\n  function FibMatExp(a: TFibMat; n: Int64): TFibmat;\n  begin\n    if n <= 1 then fibmatexp := a\n    else if (n mod 2 = 0) then FibMatExp := FibMatExp(FibMatMul(a,a), n div 2)\n    else if (n mod 2 = 1) then FibMatExp := FibMatMul(a, FibMatExp(FibMatMul(a,a), n div 2));\n  end;\n\nvar \n  matrix: TFibMat;\n	\nbegin\n  matrix[0,0] := 1;\n  matrix[0,1] := 1;\n  matrix[1,0] := 1;\n  matrix[1,1] := 0;\n  if n > 1 then\n    matrix := fibmatexp(matrix,n-1);\n  fib := matrix[0,0];\nend;",
    "import extensions;\n \nfibu(n)\n{\n    int[] ac := new int[]{ 0,1 };\n    if (n < 2) \n    {\n        ^ ac[n] \n    }\n    else\n    {\n        for(int i := 2; i <= n; i+=1)\n        {\n            int t := ac[1];\n            ac[1] := ac[0] + ac[1];\n            ac[0] := t\n        };\n \n        ^ ac[1]\n    }\n}\n \npublic program()\n{\n    for(int i := 0; i <= 10; i+=1)\n    {\n        console.printLine(fibu(i))\n    }\n}",
    "import extensions;\n\npublic FibonacciGenerator\n{\n    yieldable next()\n    {\n        long n_2 := 1l; \n        long n_1 := 1l;\n\n        $yield n_2;             \n        $yield n_1;\n\n        while(true)\n        {\n            long n := n_2 + n_1;\n\n            $yield n;\n\n            n_2 := n_1;\n            n_1 := n\n        }\n    }\n}\n\npublic program()\n{\n    auto e := new FibonacciGenerator();\n    \n    for(int i := 0; i < 10; i += 1) {\n        console.printLine(e.next())\n    };\n    \n    console.readChar()\n}",
    "(defun fibonacci (n)\n  (let (vec i j k)\n    (if (< n 2)\n        n\n      (setq vec (make-vector (+ n 1) 0)\n            i 0\n            j 1\n            k 2)\n      (setf (aref vec 1) 1)\n      (while (<= k n)\n        (setf (aref vec k) (+ (elt vec i) (elt vec j)))\n        (setq i (1+ i)\n              j (1+ j)\n              k (1+ k)))\n      (elt vec n))))",
    "#include <stdio.h>\ninclude std/mathcons.e -- for PINF constant\n\nenum ADD, MOVE, GOTO, OUT, TEST, TRUETO\n\nglobal sequence tape = { 0, \n			 1, \n		       { ADD, 2, 1 }, \n		       { TEST, 1, PINF }, \n		       { TRUETO, 0 }, \n		       { OUT, 1, \"%.0f\\n\" }, \n		       { MOVE, 2, 1 }, \n		       { MOVE, 0, 2 }, \n		       { GOTO, 3  } }\n\nglobal integer ip\nglobal integer test\nglobal atom accum\n\nprocedure eval( sequence cmd )\n	atom i = 1\n	while i <= length( cmd ) do\n		switch cmd[ i ] do\n			case ADD then\n				accum = tape[ cmd[ i + 1 ] ] + tape[ cmd[ i + 2 ] ]\n				i += 2\n\n			case OUT then\n				printf( 1, cmd[ i + 2], tape[ cmd[ i + 1 ] ] ) \n				i += 2\n\n			case MOVE then\n				if cmd[ i + 1 ] = 0 then\n					tape[ cmd[ i + 2 ] ] = accum\n				else\n					tape[ cmd[ i + 2 ] ] = tape[ cmd[ i + 1 ] ]\n				end if\n				i += 2\n\n			case GOTO then\n				ip = cmd[ i + 1 ] - 1 -- due to ip += 1 in main loop\n				i += 1\n\n			case TEST then\n				if tape[ cmd[ i + 1 ] ] = cmd[ i + 2 ] then\n					test = 1\n				else\n					test = 0\n				end if\n				i += 2\n\n			case TRUETO then\n				if test then\n					if cmd[ i + 1 ] = 0 then\n						abort(0)\n					else\n						ip = cmd[ i + 1 ] - 1\n					end if\n				end if\n\n		end switch\n		i += 1\n	end while\nend procedure\n\ntest = 0\naccum = 0\nip = 1\n\nwhile 1 do\n\n	-- embedded sequences (assumed to be code) are evaluated\n	-- atoms (assumed to be data) are ignored\n\n	if sequence( tape[ ip ] ) then\n		eval( tape[ ip ] ) \n	end if\n	ip += 1\nend while",
    "class Main\n{\n  static Int fib (Int n) \n  {\n    if (n < 2) return n\n    fibNums := [1, 0]\n    while (fibNums.size <= n)\n    {\n      fibNums.insert (0, fibNums[0] + fibNums[1])\n    }\n    return fibNums.first\n  }\n\n  public static Void main ()\n  {\n    20.times |n| \n    {\n      echo (\"Fib($n) is ${fib(n)}\")\n    }\n  }\n}",
    "#include <stdio.h>\nwindow 1, @\"Fibonacci Sequence\", (0,0,480,620)\n\nlocal fn Fibonacci( n as long ) as long\n  static long s1\n  static long s2\n  long        temp\n  \n  if ( n < 2 )\n    s1 = n\n    exit fn\n  else\n    temp = s1 + s2\n    s2 = s1\n    s1 = temp\n    exit fn\n  end if\nend fn = s1\n\nlong i\nCFTimeInterval t\n\nt = fn CACurrentMediaTime\n\nfor i = 0 to 40\n  print i;@\".\\t\";fn Fibonacci(i)\nnext i\n\nprint : printf @\"Compute time: %.3f ms\",(fn CACurrentMediaTime-t)*1000\n\nHandleEvents",
    "// Creating and printing a List\nusing System;\nusing System.Collections.Generic;\n\nclass Geeks\n{\n    public static void Main()\n    {\n        List<string> l = new List<string> { \"C#\", \"Java\", \"Javascript\" };\n        \n        foreach (string name in l)\n        {\n            Console.WriteLine(name);\n        }\n    }\n}",
    "// C# program to Add elements to a LinkedList\nusing System;\nusing System.Collections.Generic;\n\nclass Geeks \n{\n    static void Main()\n    {\n        // Create a new LinkedList of strings\n        LinkedList<int> l = new LinkedList<int>();\n\n        // Add elements to the LinkedList\n\n        // Adds at the end\n        l.AddLast(3);\n        // Adds at the beginning\n        l.AddFirst(5);\n        // Adds at the end\n        l.AddLast(7);\n        // Adds at the end\n        l.AddLast(0);\n\n        // Display the elements in the LinkedList\n        Console.WriteLine(\"Elements in the LinkedList:\");\n        foreach(var i in l)\n        { \n          Console.WriteLine(i); \n        }\n    }\n}",
    "// C# program Implementing Stack class\nusing System;\nusing System.Collections.Generic;\n\npublic class Geeks\n {\n    public static void Main(string[] args)\n    {\n        // Create a new stack\n        Stack<int> s = new Stack<int>();\n\n        // Push elements onto the stack\n        s.Push(1);\n        s.Push(2);\n        s.Push(3);\n        s.Push(4);\n        \n        // Peek element\n        Console.WriteLine(\"Peek element of stack: \"+ s.Peek());\n        \n        // Pop elements from the stack\n        while (s.Count > 0) {\n            Console.WriteLine(\"Elements of Stack: \"+ s.Pop());\n        }\n    }\n}",
    "// C# program to demonstrates the working of queue\nusing System;\nusing System.Collections;\n\npublic class Geeks \n{\n    static public void Main()\n    {\n        // Create a queue\n        // Using Queue class\n        Queue q = new Queue();\n\n        // Adding elements in Queue\n        // Using Enqueue() method\n        q.Enqueue(\"GFG\");\n        q.Enqueue(10);\n        q.Enqueue(null);\n        q.Enqueue(3.5);\n        q.Enqueue(\"Geeks123\");\n\n      // Display the first element deque in the queue\n      Console.WriteLine(q.Dequeue());\n\n        // Accessing the elements\n        // of q Queue\n        // Using foreach loop\n        foreach(var i in q) \n        { \n          Console.WriteLine(\"Elements of Queue: \"+ i); \n        }\n    }\n}",
    "using System;\nusing System.Collections.Generic;\n\nclass Geeks\n{\n    static void Main()\n    {\n        // Create a priority queue with string elements and int priorities\n        PriorityQueue<string, int> pq = new PriorityQueue<string, int>();\n\n        // Enqueue elements with their priorities\n        pq.Enqueue(\"Low priority task\", 3);\n        pq.Enqueue(\"Medium priority task\", 5);\n        pq.Enqueue(\"High priority task\", 7);\n        pq.Enqueue(\"Highest priority task\", 10);\n\n        // Dequeue elements and print them\n        while (pq.Count > 0)\n        {\n            // Dequeue the highest priority element\n            string item = pq.Dequeue();\n            Console.WriteLine(\"Processing: \" + item);\n        }\n    }\n}",
    "// C# program to demonstrate how to \n// create and display a dictionary\nusing System;\nusing System.Collections.Generic;\n\nclass Geeks\n{\n    public static void Main()\n    {\n        // Creating a dictionary\n        Dictionary<int, string> sub = new Dictionary<int, string>();\n\n        // Adding elements\n        sub.Add(1, \"One\");\n        sub.Add(2, \"Two\");\n        sub.Add(3, \"Three\");\n\n        // Displaying dictionary\n        foreach (var ele in sub)\n        {\n            Console.WriteLine($\"Key: {ele.Key}, Value: {ele.Value}\");\n        }\n    }\n}",
    "// Creating and adding key, values to the sorted list\nusing System;\nusing System.Collections.Generic;\n\nclass Geeks\n{\n    public static void Main()\n    {\n        // Creating a SortedList\n        SortedList<int, string> sl = new SortedList<int, string>();\n\n        // Adding key-value pairs\n        sl.Add(3, \"Three\");\n        sl.Add(1, \"One\");\n        sl.Add(2, \"Two\");\n\n        // Displaying elements in sorted by key\n        foreach (var item in sl)\n        {\n            Console.WriteLine($\"Key: {item.Key}, Value: {item.Value}\");\n        }\n    }\n}",
    "// C# program to add elements to the hashtable\nusing System;\nusing System.Collections;\n\nclass Geeks \n{\n    static void Main()\n    {\n        // Create a new Hashtable\n        Hashtable ht = new Hashtable();\n\n        // Add key-value pairs to the Hashtable\n        ht.Add(\"One\", 1);\n        ht.Add(\"Two\", 2);\n        ht.Add(\"Three\", 3);\n\n        Console.WriteLine(\"Hashtable elements:\");\n        foreach(DictionaryEntry e in ht)\n        {\n            Console.WriteLine($\"{e.Key}: {e.Value}\");\n        }\n    }\n}",
    "// C# Program to demonstrate the use of HashSet\nusing System;\nusing System.Collections.Generic;\n\nclass Geeks \n{\n    public static void Main(string[] args)\n    {\n        // Instantiate an object of HashSet\n        HashSet<int> hs = new HashSet<int>();\n\n        // Adding elements\n        hs.Add(1);\n        hs.Add(2);\n        hs.Add(3);\n      \n        // Duplicate element, will not be added\n        hs.Add(1);\n\n        // Printing the Size and Element of HashSet\n        Console.WriteLine(\"HashSet Size: \" + hs.Count);\n        Console.WriteLine(\"Elements in HashSet: \"\n        + string.Join(\", \", hs));\n    }\n}",
    "// C# program to demonstrate the use of SortedSet\nusing System;\nusing System.Collections.Generic;\n\nclass Geeks \n{\n    public static void Main() {\n      \n        // Creating a SortedSet\n        SortedSet<int> num = \n          new SortedSet<int> { 7, 1, 2, 8, 1, 4 };\n\n        // Adding elements\n        num.Add(6);\n      \n        // Adding duplicate (will not be added)\n        num.Add(2);\n\n        // Displaying elements\n        Console.WriteLine(\"SortedSet elements:\");\n        foreach (int ele in num)\n            Console.Write(ele + \" \");\n    }\n}",
    "// Example of Tuple\nusing System;\n\npublic class Geeks\n{\n      // Main Method \n    static public void Main()\n    {\n          // Creating a Tuple\n        var tuple = (123, \"Hello\", true);\n        \n          // Accessing the Elements\n        Console.WriteLine(tuple.Item1); \n        Console.WriteLine(tuple.Item2); \n        Console.WriteLine(tuple.Item3); \n    }\n}",
    "// Example of Tuple\nusing System;\n\npublic class Geeks\n{\n    // Main Method \n    static public void Main()\n    {\n        // ValueTuple with three elements\n        ValueTuple<string, string, int> vt = new \n        ValueTuple<string, string, int>(\"C#\", \"Java\", 357);\n\n        // Accessing the Elements\n        Console.WriteLine(\"First Element: \" + vt.Item1);\n        Console.WriteLine(\"Second Element: \" + vt.Item2);\n        Console.WriteLine(\"Third Element: \" + vt.Item3);\n    }\n}",
    "using System;\nusing System.Collections;\n\nclass Geeks \n{\n    static void Main(string[] args)\n    {\n        // Creating a BitArray with 5 bits (initialized to\n        // false by default)\n        BitArray b = new BitArray(5);\n\n        // Setting individual bits\n        b[0] = true;\n        b[1] = true;\n        b[3] = true;\n\n        // Printing the BitArray (will display true or false\n        // for each bit)\n        for (int i = 0; i < b.Count; i++) \n        {\n            Console.WriteLine(\n                $\"Bit at index {i}: {b[i]}\");\n        }\n    }\n}",
    "using System;\nusing System.Collections.Generic;\n\nclass Geeks\n{\n    static void PrintParents(int node, List<List<int>> adj, int parent)\n    {\n        if (parent == 0)\n        {\n            Console.WriteLine($\"{node} -> Root\");\n        }\n        else\n        {\n            Console.WriteLine($\"{node} -> {parent}\");\n        }\n\n        foreach (int cur in adj[node])\n        {\n            if (cur != parent)\n            {\n                PrintParents(cur, adj, node);\n            }\n        }\n    }\n\n    static void PrintChildren(int Root, List<List<int>> adj)\n    {\n        Queue<int> q = new Queue<int>();\n        q.Enqueue(Root);\n        bool[] vis = new bool[adj.Count];\n\n        while (q.Count > 0)\n        {\n            int node = q.Dequeue();\n            vis[node] = true;\n            Console.Write($\"{node} -> \");\n\n            foreach (int cur in adj[node])\n            {\n                if (!vis[cur])\n                {\n                    Console.Write($\"{cur} \");\n                    q.Enqueue(cur);\n                }\n            }\n            Console.WriteLine();\n        }\n    }\n\n    static void PrintLeafNodes(int Root, List<List<int>> adj)\n    {\n        for (int i = 0; i < adj.Count; i++)\n        {\n            if (adj[i].Count == 1 && i != Root)\n            {\n                Console.Write($\"{i} \");\n            }\n        }\n        Console.WriteLine();\n    }\n\n    static void PrintDegrees(int Root, List<List<int>> adj)\n    {\n        for (int i = 1; i < adj.Count; i++)\n        {\n            Console.Write($\"{i}: \");\n\n            if (i == Root)\n            {\n                Console.WriteLine(adj[i].Count);\n            }\n            else\n            {\n                Console.WriteLine(adj[i].Count - 1);\n            }\n        }\n    }\n\n    static void Main(string[] args)\n    {\n        int N = 7;\n        int Root = 1;\n        List<List<int>> adj = new List<List<int>>();\n\n        for (int i = 0; i <= N; i++)\n        {\n            adj.Add(new List<int>());\n        }\n\n        adj[1].AddRange(new int[] { 2, 3, 4 });\n        adj[2].AddRange(new int[] { 1, 5, 6 });\n        adj[4].Add(7);\n\n        Console.WriteLine(\"The parents of each node are:\");\n        PrintParents(Root, adj, 0);\n\n        Console.WriteLine(\"The children of each node are:\");\n        PrintChildren(Root, adj);\n\n        Console.WriteLine(\"The leaf nodes of the tree are:\");\n        PrintLeafNodes(Root, adj);\n\n        Console.WriteLine(\"The degrees of each node are:\");\n        PrintDegrees(Root, adj);\n    }\n}",
    "using System;\nusing System.Collections.Generic;\n\npublic class MaxHeap<T> where T : IComparable<T>\n{\n    private List<T> elements = new List<T>();\n\n    public int Size => elements.Count;\n\n    public bool IsEmpty => elements.Count == 0;\n\n    public void Add(T item)\n    {\n        elements.Add(item);\n        HeapifyUp(elements.Count - 1);\n    }\n\n    public T Peek()\n    {\n        if (elements.Count == 0)\n            throw new InvalidOperationException(\"Heap is empty\");\n        return elements[0];\n    }\n\n    public T RemoveMax()\n    {\n        if (elements.Count == 0)\n            throw new InvalidOperationException(\"Heap is empty\");\n\n        T result = elements[0];\n        elements[0] = elements[elements.Count - 1];\n        elements.RemoveAt(elements.Count - 1);\n        HeapifyDown(0);\n\n        return result;\n    }\n\n// HeapifyUp and HeapifyDown Oprations\n    private void HeapifyUp(int index)\n    {\n        while (index > 0)\n        {\n            int parentIndex = (index - 1) / 2;\n            if (elements[index].CompareTo(elements[parentIndex]) <= 0)\n                break;\n\n            Swap(index, parentIndex);\n            index = parentIndex;\n        }\n    }\n\n    private void HeapifyDown(int index)\n    {\n        while (index < elements.Count / 2)\n        {\n            int leftChildIndex = 2 * index + 1;\n            int rightChildIndex = 2 * index + 2;\n            int largerChildIndex = leftChildIndex;\n\n            if (rightChildIndex < elements.Count && elements[rightChildIndex].CompareTo(elements[leftChildIndex]) > 0)\n            {\n                largerChildIndex = rightChildIndex;\n            }\n\n            if (elements[index].CompareTo(elements[largerChildIndex]) >= 0)\n                break;\n\n            Swap(index, largerChildIndex);\n            index = largerChildIndex;\n        }\n    }\n    \n    // Swap two elements in the heap\n    private void Swap(int index1, int index2)\n    {\n        T temp = elements[index1];\n        elements[index1] = elements[index2];\n        elements[index2] = temp;\n    }\n}\n\n// Main class\nclass Geeks\n{\n    static void Main()\n    {\n        MaxHeap<int> maxHeap = new MaxHeap<int>();\n        maxHeap.Add(3);\n        maxHeap.Add(5);\n        maxHeap.Add(7);\n        maxHeap.Add(10);\n\n        // Max element in the heap\n        Console.WriteLine(\"Max element: \" + maxHeap.Peek());\n\n       // Traverse in the heap\n        while (!maxHeap.IsEmpty)\n        {  \n            // Remove max element one by one\n            Console.WriteLine(maxHeap.RemoveMax());\n        }\n    }\n}",
    "using System;\nusing System.Collections.Generic;\n\npublic class MinHeap<T> where T : IComparable<T>\n{\n    private List<T> elements = new List<T>();\n\n    public int Size => elements.Count;\n\n    public bool IsEmpty => elements.Count == 0;\n\n    public void Add(T item)\n    {\n        elements.Add(item);\n        HeapifyUp(elements.Count - 1);\n    }\n\n    public T Peek()\n    {\n        if (elements.Count == 0)\n            throw new InvalidOperationException(\"Heap is empty\");\n        return elements[0];\n    }\n\n    public T RemoveMin()\n    {\n        if (elements.Count == 0)\n            throw new InvalidOperationException(\"Heap is empty\");\n\n        T result = elements[0];\n        elements[0] = elements[elements.Count - 1];\n        elements.RemoveAt(elements.Count - 1);\n        HeapifyDown(0);\n\n        return result;\n    }\n\n    private void HeapifyUp(int index)\n    {\n        while (index > 0)\n        {\n            int parentIndex = (index - 1) / 2;\n            if (elements[index].CompareTo(elements[parentIndex]) >= 0)\n                break;\n\n            Swap(index, parentIndex);\n            index = parentIndex;\n        }\n    }\n\n    private void HeapifyDown(int index)\n    {\n        while (index < elements.Count / 2)\n        {\n            int leftChildIndex = 2 * index + 1;\n            int rightChildIndex = 2 * index + 2;\n            int smallerChildIndex = leftChildIndex;\n\n            if (rightChildIndex < elements.Count && elements[rightChildIndex].CompareTo(elements[leftChildIndex]) < 0)\n            {\n                smallerChildIndex = rightChildIndex;\n            }\n\n            if (elements[index].CompareTo(elements[smallerChildIndex]) <= 0)\n                break;\n\n            Swap(index, smallerChildIndex);\n            index = smallerChildIndex;\n        }\n    }\n\n    private void Swap(int index1, int index2)\n    {\n        T temp = elements[index1];\n        elements[index1] = elements[index2];\n        elements[index2] = temp;\n    }\n}\n\nclass Geeks\n{\n    static void Main()\n    {\n        MinHeap<int> minHeap = new MinHeap<int>();\n        minHeap.Add(10);\n        minHeap.Add(5);\n        minHeap.Add(20);\n        minHeap.Add(1);\n\n        // Min element in the heap\n        Console.WriteLine(\"Min element: \" + minHeap.Peek());\n\n        // Traverse in the heap\n        while (!minHeap.IsEmpty)\n        {\n            // Remove min element one by one\n            Console.WriteLine(minHeap.RemoveMin());\n        }\n    }\n}",
    "using System;\n\npublic class Geeks\n{\n    // Add an edge between two vertices\n    public static void AddEdge(int[,] mat, int i, int j)\n    {\n        mat[i, j] = 1; // Since the graph is \n        mat[j, i] = 1; // undirected\n    }\n\n    // Display the adjacency matrix\n    public static void DisplayMatrix(int[,] mat)\n    {\n        int V = mat.GetLength(0); \n        for (int i = 0; i < V; i++)\n        {\n            for (int j = 0; j < V; j++)\n            {\n                Console.Write(mat[i, j] + \" \");\n            }\n            Console.WriteLine(); \n        }\n    }\n\n    // Main method to run the program\n    public static void Main(string[] args)\n    {\n        int V = 4; // Number of vertices\n        int[,] mat = new int[V, V]; // Initialize matrix\n\n        // Add edges to the graph\n        AddEdge(mat, 0, 1);\n        AddEdge(mat, 0, 2);\n        AddEdge(mat, 1, 2);\n        AddEdge(mat, 2, 3);\n\n        // Optionally, initialize matrix directly\n        /*\n        int[,] mat = new int[,]\n        {\n            { 0, 1, 0, 0 },\n            { 1, 0, 1, 0 },\n            { 0, 1, 0, 1 },\n            { 0, 0, 1, 0 }\n        };\n        */\n\n        // Display adjacency matrix\n        Console.WriteLine(\"Adjacency Matrix:\");\n        DisplayMatrix(mat);\n    }\n}",
    "using System;\nusing System.Collections.Generic;\n\npublic class Geeks\n{\n    // Method to add an edge between two vertices\n    public static void AddEdge(List<List<int>> adj, int i, int j)\n    {\n         // Undirected\n        adj[i].Add(j);\n        adj[j].Add(i);\n    }\n\n    // Method to display the adjacency list\n    public static void DisplayAdjList(List<List<int>> adj)\n    {\n        for (int i = 0; i < adj.Count; i++)\n        {\n            Console.Write($\"{i}: \"); // Print the vertex\n            foreach (int j in adj[i])\n            {\n                Console.Write($\"{j} \"); // Print its adjacent\n            }\n            Console.WriteLine(); \n        }\n    }\n\n    // Main method\n    public static void Main(string[] args)\n    {\n        // Create a graph with 4 vertices and no edges\n        int V = 4;\n        List<List<int>> adj = new List<List<int>>(V); \n        for (int i = 0; i < V; i++)\n            adj.Add(new List<int>());\n\n        // Now add edges one by one\n        AddEdge(adj, 0, 1);\n        AddEdge(adj, 0, 2);\n        AddEdge(adj, 1, 2);\n        AddEdge(adj, 2, 3);\n\n        Console.WriteLine(\"Adjacency List Representation:\");\n        DisplayAdjList(adj);\n    }\n}",
    "#include <stdio.h>\nint main() {\n    int num;\n    printf(\"Enter an integer: \");\n    scanf(\"%d\", &num);\n\n    // true if num is perfectly divisible by 2\n    if(num % 2 == 0)\n        printf(\"%d is even.\", num);\n    else\n        printf(\"%d is odd.\", num);\n    \n    return 0;\n}",
    "#include <math.h>\n#include <stdio.h>\nint main() {\n    double a, b, c, discriminant, root1, root2, realPart, imagPart;\n    printf(\"Enter coefficients a, b and c: \");\n    scanf(\"%lf %lf %lf\", &a, &b, &c);\n\n    discriminant = b * b - 4 * a * c;\n\n    // condition for real and different roots\n    if (discriminant > 0) {\n        root1 = (-b + sqrt(discriminant)) / (2 * a);\n        root2 = (-b - sqrt(discriminant)) / (2 * a);\n        printf(\"root1 = %.2lf and root2 = %.2lf\", root1, root2);\n    }\n\n    // condition for real and equal roots\n    else if (discriminant == 0) {\n        root1 = root2 = -b / (2 * a);\n        printf(\"root1 = root2 = %.2lf;\", root1);\n    }\n\n    // if roots are not real\n    else {\n        realPart = -b / (2 * a);\n        imagPart = sqrt(-discriminant) / (2 * a);\n        printf(\"root1 = %.2lf+%.2lfi and root2 = %.2f-%.2fi\", realPart, imagPart, realPart, imagPart);\n    }\n\n    return 0;\n}",
    "#include <stdio.h>\nint main() {\n   int i, j, rows;\n   printf(\"Enter the number of rows: \");\n   scanf(\"%d\", &rows);\n   for (i = 1; i <= rows; ++i) {\n      for (j = 1; j <= i; ++j) {\n         printf(\"* \");\n      }\n      printf(\"\\n\");\n   }\n   return 0;\n}",
    "#include <stdio.h>\n\nint main() {\n\n  int n, i, flag = 0;\n  printf(\"Enter a positive integer: \");\n  scanf(\"%d\", &n);\n\n  // 0 and 1 are not prime numbers\n  // change flag to 1 for non-prime number\n  if (n == 0 || n == 1)\n    flag = 1;\n\n  for (i = 2; i <= n / 2; ++i) {\n\n    // if n is divisible by i, then n is not prime\n    // change flag to 1 for non-prime number\n    if (n % i == 0) {\n      flag = 1;\n      break;\n    }\n  }\n\n  // flag is 0 for prime numbers\n  if (flag == 0)\n    printf(\"%d is a prime number.\", n);\n  else\n    printf(\"%d is not a prime number.\", n);\n\n  return 0;\n}",
    "#include <stdio.h>\nint main() {\n\n  int i, n;\n\n  // initialize first and second terms\n  int t1 = 0, t2 = 1;\n\n  // initialize the next term (3rd term)\n  int nextTerm = t1 + t2;\n\n  // get no. of terms from user\n  printf(\"Enter the number of terms: \");\n  scanf(\"%d\", &n);\n\n  // print the first two terms t1 and t2\n  printf(\"Fibonacci Series: %d, %d, \", t1, t2);\n\n  // print 3rd to nth terms\n  for (i = 3; i <= n; ++i) {\n    printf(\"%d, \", nextTerm);\n    t1 = t2;\n    t2 = nextTerm;\n    nextTerm = t1 + t2;\n  }\n\n  return 0;\n}",
    "#include <stdio.h>\nint main() {\n  int n, reversed = 0, remainder, original;\n    printf(\"Enter an integer: \");\n    scanf(\"%d\", &n);\n    original = n;\n\n    // reversed integer is stored in reversed variable\n    while (n != 0) {\n        remainder = n % 10;\n        reversed = reversed * 10 + remainder;\n        n /= 10;\n    }\n\n    // palindrome if orignal and reversed are equal\n    if (original == reversed)\n        printf(\"%d is a palindrome.\", original);\n    else\n        printf(\"%d is not a palindrome.\", original);\n\n    return 0;\n}",
    "#include <stdio.h>\nint main() {   \n    int number;\n   \n    printf(\"Enter an integer: \");  \n    \n    // reads and stores input\n    scanf(\"%d\", &number);\n\n    // displays output\n    printf(\"You entered: %d\", number);\n    \n    return 0;\n}",
    "#include <stdio.h>\nint main() {    \n\n    int number1, number2, sum;\n    \n    printf(\"Enter two integers: \");\n    scanf(\"%d %d\", &number1, &number2);\n\n    // calculate the sum\n    sum = number1 + number2;      \n    \n    printf(\"%d + %d = %d\", number1, number2, sum);\n    return 0;\n}",
    "#include <stdio.h>\nint main() {\n    double a, b, product;\n    printf(\"Enter two numbers: \");\n    scanf(\"%lf %lf\", &a, &b);  \n \n    // Calculating product\n    product = a * b;\n\n    // %.2lf displays number up to 2 decimal point\n    printf(\"Product = %.2lf\", product);\n    \n    return 0;\n}",
    "#include <stdio.h>\nint main() {\n    int dividend, divisor, quotient, remainder;\n    printf(\"Enter dividend: \");\n    scanf(\"%d\", &dividend);\n    printf(\"Enter divisor: \");\n    scanf(\"%d\", &divisor);\n\n    // Computes quotient\n    quotient = dividend / divisor;\n\n    // Computes remainder\n    remainder = dividend % divisor;\n\n    printf(\"Quotient = %d\\n\", quotient);\n    printf(\"Remainder = %d\", remainder);\n    return 0;\n}",
    "#include<stdio.h>\nint main() {\n    int intType;\n    float floatType;\n    double doubleType;\n    char charType;\n\n    // sizeof evaluates the size of a variable\n    printf(\"Size of int: %zu bytes\\n\", sizeof(intType));\n    printf(\"Size of float: %zu bytes\\n\", sizeof(floatType));\n    printf(\"Size of double: %zu bytes\\n\", sizeof(doubleType));\n    printf(\"Size of char: %zu byte\\n\", sizeof(charType));\n    \n    return 0;\n}",
    "#include <stdio.h>\nint main() {\n    int a;\n    long b;   // equivalent to long int b;\n    long long c;  // equivalent to long long int c;\n    double e;\n    long double f;\n\n    printf(\"Size of int = %zu bytes \\n\", sizeof(a));\n    printf(\"Size of long int = %zu bytes\\n\", sizeof(b));\n    printf(\"Size of long long int = %zu bytes\\n\", sizeof(c));\n    printf(\"Size of double = %zu bytes\\n\", sizeof(e));\n    printf(\"Size of long double = %zu bytes\\n\", sizeof(f));\n    \n    return 0;\n}",
    "#include<stdio.h>\nint main() {\n  double first, second, temp;\n  printf(\"Enter first number: \");\n  scanf(\"%lf\", &first);\n  printf(\"Enter second number: \");\n  scanf(\"%lf\", &second);\n\n  // value of first is assigned to temp\n  temp = first;\n\n  // value of second is assigned to first\n  first = second;\n\n  // value of temp (initial value of first) is assigned to second\n  second = temp;\n\n  // %.2lf displays number up to 2 decimal points\n  printf(\"\\nAfter swapping, first number = %.2lf\\n\", first);\n  printf(\"After swapping, second number = %.2lf\", second);\n  return 0;\n}",
    "#include <stdio.h>\nint main() {\n    char c;\n    int lowercase_vowel, uppercase_vowel;\n    printf(\"Enter an alphabet: \");\n    scanf(\"%c\", &c);\n\n    // evaluates to 1 if variable c is a lowercase vowel\n    lowercase_vowel = (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n\n    // evaluates to 1 if variable c is a uppercase vowel\n    uppercase_vowel = (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U');\n\n    // evaluates to 1 (true) if c is a vowel\n    if (lowercase_vowel || uppercase_vowel)\n        printf(\"%c is a vowel.\", c);\n    else\n        printf(\"%c is a consonant.\", c);\n    return 0;\n}",
    "#include <stdio.h>\n\nint main() {\n\n  double n1, n2, n3;\n\n  printf(\"Enter three different numbers: \");\n  scanf(\"%lf %lf %lf\", &n1, &n2, &n3);\n\n  // if n1 is greater than both n2 and n3, n1 is the largest\n  if (n1 >= n2 && n1 >= n3)\n    printf(\"%.2f is the largest number.\", n1);\n\n  // if n2 is greater than both n1 and n3, n2 is the largest\n  if (n2 >= n1 && n2 >= n3)\n    printf(\"%.2f is the largest number.\", n2);\n\n  // if n3 is greater than both n1 and n2, n3 is the largest\n  if (n3 >= n1 && n3 >= n2)\n    printf(\"%.2f is the largest number.\", n3);\n\n  return 0;\n}",
    "#include <stdio.h>\nint main() {\n   int year;\n   printf(\"Enter a year: \");\n   scanf(\"%d\", &year);\n\n   // leap year if perfectly divisible by 400\n   if (year % 400 == 0) {\n      printf(\"%d is a leap year.\", year);\n   }\n   // not a leap year if divisible by 100\n   // but not divisible by 400\n   else if (year % 100 == 0) {\n      printf(\"%d is not a leap year.\", year);\n   }\n   // leap year if not divisible by 100\n   // but divisible by 4\n   else if (year % 4 == 0) {\n      printf(\"%d is a leap year.\", year);\n   }\n   // all other years are not leap years\n   else {\n      printf(\"%d is not a leap year.\", year);\n   }\n\n   return 0;\n}",
    "#include <stdio.h>\n\nint main() {\n\n    double num;\n    printf(\"Enter a number: \");\n    scanf(\"%lf\", &num);\n    if (num <= 0.0) {\n        if (num == 0.0)\n            printf(\"You entered 0.\");\n        else\n            printf(\"You entered a negative number.\");\n    } \n    else\n        printf(\"You entered a positive number.\");\n\n    return 0;\n}",
    "#include <stdio.h>\nint main() {\n    char c;\n    printf(\"Enter a character: \");\n    scanf(\"%c\", &c);\n\n    if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))\n        printf(\"%c is an alphabet.\", c);\n    else\n        printf(\"%c is not an alphabet.\", c);\n\n    return 0;\n}",
    "#include <stdio.h>\nint main() {\n    int n, i, sum = 0;\n\n    printf(\"Enter a positive integer: \");\n    scanf(\"%d\", &n);\n\n    for (i = 1; i <= n; ++i) {\n        sum += i;\n    }\n\n    printf(\"Sum = %d\", sum);\n    return 0;\n}",
    "#include <stdio.h>\nint main() {\n    int n, i;\n    unsigned long long fact = 1;\n    printf(\"Enter an integer: \");\n    scanf(\"%d\", &n);\n\n    // shows error if the user enters a negative integer\n    if (n < 0)\n        printf(\"Error! Factorial of a negative number doesn't exist.\");\n    else {\n        for (i = 1; i <= n; ++i) {\n            fact *= i;\n        }\n        printf(\"Factorial of %d = %llu\", n, fact);\n    }\n\n    return 0;\n}",
    "#include <stdio.h>\nint main() {\n\n  int n, i, range;\n  printf(\"Enter an integer: \");\n  scanf(\"%d\", &n);\n\n  // prompt user for positive range\n  do {\n    printf(\"Enter the range (positive integer): \");\n    scanf(\"%d\", &range);\n  } while (range <= 0);\n\n  for (i = 1; i <= range; ++i) {\n    printf(\"%d * %d = %d \\n\", n, i, n * i);\n  }\n\n  return 0;\n}",
    "#include <stdio.h>\nint main()\n{\n    int n1, n2, i, gcd;\n\n    printf(\"Enter two integers: \");\n    scanf(\"%d %d\", &n1, &n2);\n\n    for(i=1; i <= n1 && i <= n2; ++i)\n    {\n        // Checks if i is factor of both integers\n        if(n1%i==0 && n2%i==0)\n            gcd = i;\n    }\n\n    printf(\"G.C.D of %d and %d is %d\", n1, n2, gcd);\n\n    return 0;\n}",
    "#include <stdio.h>\n\nint main() {\n\n    int n1, n2, max, lcm;\n\n    printf(\"Enter two positive integers: \");\n    scanf(\"%d %d\", &n1, &n2);\n\n    // maximum number between n1 and n2 is stored in max\n    max = (n1 > n2) ? n1 : n2;\n\n    lcm = max;\n\n    while ((lcm % n1 != 0) || (lcm % n2 != 0)) {\n        lcm += max;\n    }\n\n    printf(\"The LCM of %d and %d is %d.\", n1, n2, lcm);\n\n    return 0;\n}",
    "#include <stdio.h>\nint main() {\n    char c;\n    printf(\"Enter u to display uppercase alphabets.\\n\");\n    printf(\"Enter l to display lowercase alphabets. \\n\");\n    scanf(\"%c\", &c);\n\n    if (c == 'U' || c == 'u') {\n        for (c = 'A'; c <= 'Z'; ++c)\n            printf(\"%c \", c);\n    } else if (c == 'L' || c == 'l') {\n        for (c = 'a'; c <= 'z'; ++c)\n            printf(\"%c \", c);\n    } else {\n        printf(\"Error! You entered an invalid character.\");\n    }\n\n    return 0;\n}",
    "#include <stdio.h>\nint main() {\n  long long n;\n  int count = 0;\n  printf(\"Enter an integer: \");\n  scanf(\"%lld\", &n);\n \n  // iterate at least once, then until n becomes 0\n  // remove last digit from n in each iteration\n  // increase count by 1 in each iteration\n  do {\n    n /= 10;\n    ++count;\n  } while (n != 0);\n\n  printf(\"Number of digits: %d\", count);\n}",
    "#include <stdio.h>\n\nint main() {\n  int n, reverse = 0, remainder, original;\n\n  printf(\"Enter an integer: \");\n  scanf(\"%d\", &n);\n\n  original = n;  \n\n  while (n != 0) {\n    remainder = n % 10;\n    reverse = reverse * 10 + remainder;\n    n /= 10;\n  }\n\n  if (original % 10 == 0) {\n    printf(\"Reversed number = %d\", reverse);\n    \n    while (original % 10 == 0) {\n      printf(\"0\");\n      original /= 10;\n    }\n  } else {\n    printf(\"Reversed number = %d\", reverse);\n  }\n\n  return 0;\n}",
    "#include <stdio.h>\nint main() {\n    int base, exp;\n    long double result = 1.0;\n    printf(\"Enter a base number: \");\n    scanf(\"%d\", &base);\n    printf(\"Enter an exponent: \");\n    scanf(\"%d\", &exp);\n\n    while (exp != 0) {\n        result *= base;\n        --exp;\n    }\n    printf(\"Answer = %.0Lf\", result);\n    return 0;\n}",
    "#include <stdio.h>\n\nint main() {\n   int low, high, i, flag;\n   printf(\"Enter two numbers(intervals): \");\n   scanf(\"%d %d\", &low, &high);\n   printf(\"Prime numbers between %d and %d are: \", low, high);\n\n   // iteration until low is not equal to high\n   while (low < high) {\n      flag = 0;\n\n      // ignore numbers less than 2\n      if (low <= 1) {\n         ++low;\n         continue;\n      }\n\n      // if low is a non-prime number, flag will be 1\n      for (i = 2; i <= low / 2; ++i) {\n\n         if (low % i == 0) {\n            flag = 1;\n            break;\n         }\n      }\n\n      if (flag == 0)\n         printf(\"%d \", low);\n\n      // to check prime for the next number\n      // increase low by 1\n      ++low;\n   }\n\n   return 0;\n}",
    "#include <stdio.h>\nint main() {\n    int num, originalNum, remainder, result = 0;\n    printf(\"Enter a three-digit integer: \");\n    scanf(\"%d\", &num);\n    originalNum = num;\n\n    while (originalNum != 0) {\n       // remainder contains the last digit\n        remainder = originalNum % 10;\n        \n       result += remainder * remainder * remainder;\n        \n       // removing last digit from the orignal number\n       originalNum /= 10;\n    }\n\n    if (result == num)\n        printf(\"%d is an Armstrong number.\", num);\n    else\n        printf(\"%d is not an Armstrong number.\", num);\n\n    return 0;\n}",
    "#include <math.h>\n#include <stdio.h>\nint main() {\n  int low, high, number, originalNumber, rem, count = 0;\n  double result = 0.0;\n  printf(\"Enter two numbers(intervals): \");\n  scanf(\"%d %d\", &low, &high);\n  printf(\"Armstrong numbers between %d and %d are: \", low, high);\n\n  // swap numbers if high < low\n  if (high < low) {\n    high += low;\n    low = high - low;\n    high -= low;\n  }\n   \n  // iterate number from (low + 1) to (high - 1)\n  // In each iteration, check if number is Armstrong\n  for (number = low + 1; number < high; ++number) {\n    originalNumber = number;\n\n    // number of digits calculation\n    while (originalNumber != 0) {\n      originalNumber /= 10;\n      ++count;\n    }\n\n    originalNumber = number;\n\n    // result contains sum of nth power of individual digits\n    while (originalNumber != 0) {\n      rem = originalNumber % 10;\n      result += pow(rem, count);\n      originalNumber /= 10;\n    }\n\n    // check if number is equal to the sum of nth power of individual digits\n    if ((int)result == number) {\n      printf(\"%d \", number);\n    }\n\n    // resetting the values\n    count = 0;\n    result = 0;\n  }\n\n  return 0;\n}",
    "#include <stdio.h>\nint main() {\n    int num, i;\n    printf(\"Enter a positive integer: \");\n    scanf(\"%d\", &num);\n    printf(\"Factors of %d are: \", num);\n    for (i = 1; i <= num; ++i) {\n        if (num % i == 0) {\n            printf(\"%d \", i);\n        }\n    }\n    return 0;\n}",
    "#include <stdio.h>\n\nint main() {\n\n  char op;\n  double first, second;\n  printf(\"Enter an operator (+, -, *, /): \");\n  scanf(\"%c\", &op);\n  printf(\"Enter two operands: \");\n  scanf(\"%lf %lf\", &first, &second);\n\n  switch (op) {\n    case '+':\n      printf(\"%.1lf + %.1lf = %.1lf\", first, second, first + second);\n      break;\n    case '-':\n      printf(\"%.1lf - %.1lf = %.1lf\", first, second, first - second);\n      break;\n    case '*':\n      printf(\"%.1lf * %.1lf = %.1lf\", first, second, first * second);\n      break;\n    case '/':\n      printf(\"%.1lf / %.1lf = %.1lf\", first, second, first / second);\n      break;\n    // operator doesn't match any case constant\n    default:\n      printf(\"Error! operator is not correct\");\n  }\n\n  return 0;\n}",
    "#include <stdio.h>\nint checkPrimeNumber(int n);\nint main() {\n\n  int n1, n2, i, flag;\n\n  printf(\"Enter two positive integers: \");\n  scanf(\"%d %d\", &n1, &n2);\n\n  // swap n1 and n2 if n1 > n2\n  if (n1 > n2) {\n    n1 = n1 + n2;\n    n2 = n1 - n2;\n    n1 = n1 - n2;\n  }\n\n  printf(\"Prime numbers between %d and %d are: \", n1, n2);\n  for (i = n1 + 1; i < n2; ++i) {\n\n    // flag will be equal to 1 if i is prime\n    flag = checkPrimeNumber(i);\n\n    if (flag == 1) {\n      printf(\"%d \", i);\n    }\n  }\n  \n  return 0;\n}\n\n// user-defined function to check prime number\nint checkPrimeNumber(int n) {\n  int j, flag = 1;\n\n  for (j = 2; j <= n / 2; ++j) {\n\n    if (n % j == 0) {\n      flag = 0;\n      break;\n    }\n  }\n\n  return flag;\n}",
    "#include <math.h>\n#include <stdio.h>\n\nint checkPrimeNumber(int n);\nint checkArmstrongNumber(int n);\n\nint main() {\n   int n, flag;\n   printf(\"Enter a positive integer: \");\n   scanf(\"%d\", &n);\n\n   // check prime number\n   flag = checkPrimeNumber(n);\n   if (flag == 1)\n      printf(\"%d is a prime number.\\n\", n);\n   else\n      printf(\"%d is not a prime number.\\n\", n);\n\n   // check Armstrong number\n   flag = checkArmstrongNumber(n);\n   if (flag == 1)\n      printf(\"%d is an Armstrong number.\", n);\n   else\n      printf(\"%d is not an Armstrong number.\", n);\n   return 0;\n}\n\n// function to check prime number\nint checkPrimeNumber(int n) {\n   int i, flag = 1, squareRoot;\n\n   // computing the square root\n   squareRoot = sqrt(n);\n   for (i = 2; i <= squareRoot; ++i) {\n      // condition for non-prime number\n      if (n % i == 0) {\n         flag = 0;\n         break;\n      }\n   }\n   return flag;\n}\n\n// function to check Armstrong number\nint checkArmstrongNumber(int num) {\n   int originalNum, remainder, n = 0, flag;\n   double result = 0.0;\n\n   // store the number of digits of num in n\n   for (originalNum = num; originalNum != 0; ++n) {\n      originalNum /= 10;\n   }\n\n   for (originalNum = num; originalNum != 0; originalNum /= 10) {\n      remainder = originalNum % 10;\n\n      // store the sum of the power of individual digits in result\n      result += pow(remainder, n);\n   }\n\n   // condition for Armstrong number\n   if (round(result) == num)\n      flag = 1;\n   else\n      flag = 0;\n   return flag;\n}",
    "#include <stdio.h>\nint checkPrime(int n);\nint main() {\n  int n, i, flag = 0;\n  printf(\"Enter a positive integer: \");\n  scanf(\"%d\", &n);\n\n  for (i = 2; i <= n / 2; ++i) {\n    // condition for i to be a prime number\n    if (checkPrime(i) == 1) {\n      // condition for n-i to be a prime number\n      if (checkPrime(n - i) == 1) {\n        printf(\"%d = %d + %d\\n\", n, i, n - i);\n        flag = 1;\n      }\n    }\n  }\n\n  if (flag == 0)\n    printf(\"%d cannot be expressed as the sum of two prime numbers.\", n);\n\n  return 0;\n}\n\n// function to check prime number\nint checkPrime(int n) {\n  int i, isPrime = 1;\n\n  // 0 and 1 are not prime numbers\n  if (n == 0 || n == 1) {\n    isPrime = 0;\n  }\n  else {\n    for(i = 2; i <= n/2; ++i) {\n      if(n % i == 0) {\n        isPrime = 0;\n        break;\n      }\n    }\n  }\n\n  return isPrime;\n}",
    "#include <stdio.h>\n\nint addNumbers(int n);\n\nint main() {\n\n  int num;\n  printf(\"Enter a positive integer: \");\n  scanf(\"%d\", &num);\n  printf(\"Sum = %d\", addNumbers(num));\n  return 0;\n}\n\nint addNumbers(int n) {\n  if (n != 0)\n    return n + addNumbers(n - 1);\n  else\n    return n;\n}",
    "#include<stdio.h>\nlong int multiplyNumbers(int n);\nint main() {\n    int n;\n    printf(\"Enter a positive integer: \");\n    scanf(\"%d\",&n);\n    printf(\"Factorial of %d = %ld\", n, multiplyNumbers(n));\n    return 0;\n}\n\nlong int multiplyNumbers(int n) {\n    if (n>=1)\n        return n*multiplyNumbers(n-1);\n    else\n        return 1;\n}",
    "#include <stdio.h>\nint hcf(int n1, int n2);\nint main() {\n    int n1, n2;\n    printf(\"Enter two positive integers: \");\n    scanf(\"%d %d\", &n1, &n2);\n    printf(\"G.C.D of %d and %d is %d.\", n1, n2, hcf(n1, n2));\n    return 0;\n}\n\nint hcf(int n1, int n2) {\n    if (n2 != 0)\n        return hcf(n2, n1 % n2);\n    else\n        return n1;\n}",
    "#include <stdio.h>\n\n// function prototype\nlong long convert(long long);\n\nint main() {\n\n    long long n;\n\n    printf(\"Enter a binary number: \");\n    scanf(\"%lld\", &n);\n\n    printf(\"%lld in binary = %lld in decimal\", n, convert(n));\n\n    return 0;\n}\n\n// function definition\nlong long convert(long long n) {\n\n    long long dec = 0;\n    int i = 0, rem;\n\n    while (n != 0) {\n\n        // get remainder of n divided by 10\n        rem = n % 10;\n\n        // add the rem * (2 ^ i) to dec\n        dec += rem << i; // Using bitwise shift instead of pow\n\n        // divide n by 10\n        n /= 10;\n\n        // increment i\n        ++i;\n    }\n\n    return dec;\n}",
    "#include <stdio.h>\n#include <math.h>\n\n// function prototype\nint convertDecimalToOctal(int decimalNumber);\n\nint main() {\n\n    int decimalNumber;\n\n    printf(\"Enter a decimal number: \");\n    scanf(\"%d\", &decimalNumber);\n\n    printf(\"%d in decimal = %d in octal\", decimalNumber, convertDecimalToOctal(decimalNumber));\n\n    return 0;\n}\n\n// function to convert decimalNumber to octal\nint convertDecimalToOctal(int decimalNumber) {\n    int octalNumber = 0, i = 1;\n\n    while (decimalNumber != 0) {\n        octalNumber += (decimalNumber % 8) * i;\n        decimalNumber /= 8;\n        i *= 10;\n    }\n\n    return octalNumber;\n}",
    "#include <math.h>\n#include <stdio.h>\nint convert(long long bin);\nint main() {\n    long long bin;\n    printf(\"Enter a binary number: \");\n    scanf(\"%lld\", &bin);\n    printf(\"%lld in binary = %d in octal\", bin, convert(bin));\n    return 0;\n}\n\nint convert(long long bin) {\n    int oct = 0, dec = 0, i = 0;\n\n    // converting binary to decimal\n    while (bin != 0) {\n        dec += (bin % 10) * pow(2, i);\n        ++i;\n        bin /= 10;\n    }\n    i = 1;\n\n    // converting to decimal to octal\n    while (dec != 0) {\n        oct += (dec % 8) * i;\n        dec /= 8;\n        i *= 10;\n    }\n    return oct;\n}",
    "#include <stdio.h>\nvoid reverseSentence();\nint main() {\n    printf(\"Enter a sentence: \");\n    reverseSentence();\n    return 0;\n}\n\nvoid reverseSentence() {\n    char c;\n    scanf(\"%c\", &c);\n    if (c != '\\n') {\n        reverseSentence();\n        printf(\"%c\", c);\n    }\n}",
    "#include <stdio.h>\nint power(int n1, int n2);\nint main() {\n    int base, a, result;\n    printf(\"Enter base number: \");\n    scanf(\"%d\", &base);\n    printf(\"Enter power number(positive integer): \");\n    scanf(\"%d\", &a);\n    result = power(base, a);\n    printf(\"%d^%d = %d\", base, a, result);\n    return 0;\n}\n\nint power(int base, int a) {\n    if (a != 0)\n        return (base * power(base, a - 1));\n    else\n        return 1;\n}",
    "#include <stdio.h>\nint main() {\n    int n, i;\n    float num[100], sum = 0.0, avg;\n\n    printf(\"Enter the numbers of elements: \");\n    scanf(\"%d\", &n);\n\n    while (n > 100 || n < 1) {\n        printf(\"Error! number should in range of (1 to 100).\\n\");\n        printf(\"Enter the number again: \");\n        scanf(\"%d\", &n);\n    }\n\n    for (i = 0; i < n; ++i) {\n        printf(\"%d. Enter number: \", i + 1);\n        scanf(\"%f\", &num[i]);\n        sum += num[i];\n    }\n\n    avg = sum / n;\n    printf(\"Average = %.2f\", avg);\n    return 0;\n}",
    "#include <stdio.h>\nint main() {\n  int n;\n  double arr[100];\n  printf(\"Enter the number of elements (1 to 100): \");\n  scanf(\"%d\", &n);\n\n  for (int i = 0; i < n; ++i) {\n    printf(\"Enter number%d: \", i + 1);\n    scanf(\"%lf\", &arr[i]);\n  }\n\n  // storing the largest number to arr[0]\n  for (int i = 1; i < n; ++i) {\n    if (arr[0] < arr[i]) {\n      arr[0] = arr[i];\n    }\n  }\n\n  printf(\"Largest element = %.2lf\", arr[0]);\n\n  return 0;\n}",
    "// SD of a population\n#include <math.h>\n#include <stdio.h>\nfloat calculateSD(float data[]);\nint main() {\n    int i;\n    float data[10];\n    printf(\"Enter 10 elements: \");\n    for (i = 0; i < 10; ++i)\n        scanf(\"%f\", &data[i]);\n    printf(\"\\nStandard Deviation = %.6f\", calculateSD(data));\n    return 0;\n}\n\nfloat calculateSD(float data[]) {\n    float sum = 0.0, mean, SD = 0.0;\n    int i;\n    for (i = 0; i < 10; ++i) {\n        sum += data[i];\n    }\n    mean = sum / 10;\n    for (i = 0; i < 10; ++i) {\n        SD += pow(data[i] - mean, 2);\n    }\n    return sqrt(SD / 10);\n}",
    "#include <stdio.h>\nint main() {\n  int r, c, a[100][100], b[100][100], sum[100][100], i, j;\n  printf(\"Enter the number of rows (between 1 and 100): \");\n  scanf(\"%d\", &r);\n  printf(\"Enter the number of columns (between 1 and 100): \");\n  scanf(\"%d\", &c);\n\n  printf(\"\\nEnter elements of 1st matrix:\\n\");\n  for (i = 0; i < r; ++i)\n    for (j = 0; j < c; ++j) {\n      printf(\"Enter element a%d%d: \", i + 1, j + 1);\n      scanf(\"%d\", &a[i][j]);\n    }\n\n  printf(\"Enter elements of 2nd matrix:\\n\");\n  for (i = 0; i < r; ++i)\n    for (j = 0; j < c; ++j) {\n      printf(\"Enter element b%d%d: \", i + 1, j + 1);\n      scanf(\"%d\", &b[i][j]);\n    }\n\n  // adding two matrices\n  for (i = 0; i < r; ++i)\n    for (j = 0; j < c; ++j) {\n      sum[i][j] = a[i][j] + b[i][j];\n    }\n\n  // printing the result\n  printf(\"\\nSum of two matrices: \\n\");\n  for (i = 0; i < r; ++i)\n    for (j = 0; j < c; ++j) {\n      printf(\"%d   \", sum[i][j]);\n      if (j == c - 1) {\n        printf(\"\\n\\n\");\n      }\n    }\n\n  return 0;\n}",
    "#include <stdio.h>\n\n// function to get matrix elements entered by the user\nvoid getMatrixElements(int matrix[][10], int row, int column) {\n\n   printf(\"\\nEnter elements: \\n\");\n\n   for (int i = 0; i < row; ++i) {\n      for (int j = 0; j < column; ++j) {\n         printf(\"Enter a%d%d: \", i + 1, j + 1);\n         scanf(\"%d\", &matrix[i][j]);\n      }\n   }\n}\n\n// function to multiply two matrices\nvoid multiplyMatrices(int first[][10],\n                      int second[][10],\n                      int result[][10],\n                      int r1, int c1, int r2, int c2) {\n\n   // Initializing elements of matrix mult to 0.\n   for (int i = 0; i < r1; ++i) {\n      for (int j = 0; j < c2; ++j) {\n         result[i][j] = 0;\n      }\n   }\n\n   // Multiplying first and second matrices and storing it in result\n   for (int i = 0; i < r1; ++i) {\n      for (int j = 0; j < c2; ++j) {\n         for (int k = 0; k < c1; ++k) {\n            result[i][j] += first[i][k] * second[k][j];\n         }\n      }\n   }\n}\n\n// function to display the matrix\nvoid display(int result[][10], int row, int column) {\n\n   printf(\"\\nOutput Matrix:\\n\");\n   for (int i = 0; i < row; ++i) {\n      for (int j = 0; j < column; ++j) {\n         printf(\"%d  \", result[i][j]);\n         if (j == column - 1)\n            printf(\"\\n\");\n      }\n   }\n}\n\nint main() {\n   int first[10][10], second[10][10], result[10][10], r1, c1, r2, c2;\n   printf(\"Enter rows and column for the first matrix: \");\n   scanf(\"%d %d\", &r1, &c1);\n   printf(\"Enter rows and column for the second matrix: \");\n   scanf(\"%d %d\", &r2, &c2);\n\n   // Taking input until\n   // 1st matrix columns is not equal to 2nd matrix row\n   while (c1 != r2) {\n      printf(\"Error! Enter rows and columns again.\\n\");\n      printf(\"Enter rows and columns for the first matrix: \");\n      scanf(\"%d%d\", &r1, &c1);\n      printf(\"Enter rows and columns for the second matrix: \");\n      scanf(\"%d%d\", &r2, &c2);\n   }\n\n   // get elements of the first matrix\n   getMatrixElements(first, r1, c1);\n\n   // get elements of the second matrix\n   getMatrixElements(second, r2, c2);\n\n   // multiply two matrices.\n   multiplyMatrices(first, second, result, r1, c1, r2, c2);\n\n   // display the result\n   display(result, r1, c2);\n\n   return 0;\n}",
    "#include <stdio.h>\nint main() {\n  int a[10][10], transpose[10][10], r, c;\n  printf(\"Enter rows and columns: \");\n  scanf(\"%d %d\", &r, &c);\n\n  // asssigning elements to the matrix\n  printf(\"\\nEnter matrix elements:\\n\");\n  for (int i = 0; i < r; ++i)\n  for (int j = 0; j < c; ++j) {\n    printf(\"Enter element a%d%d: \", i + 1, j + 1);\n    scanf(\"%d\", &a[i][j]);\n  }\n\n  // printing the matrix a[][]\n  printf(\"\\nEntered matrix: \\n\");\n  for (int i = 0; i < r; ++i)\n  for (int j = 0; j < c; ++j) {\n    printf(\"%d  \", a[i][j]);\n    if (j == c - 1)\n    printf(\"\\n\");\n  }\n\n  // computing the transpose\n  for (int i = 0; i < r; ++i)\n  for (int j = 0; j < c; ++j) {\n    transpose[j][i] = a[i][j];\n  }\n\n  // printing the transpose\n  printf(\"\\nTranspose of the matrix:\\n\");\n  for (int i = 0; i < c; ++i)\n  for (int j = 0; j < r; ++j) {\n    printf(\"%d  \", transpose[i][j]);\n    if (j == r - 1)\n    printf(\"\\n\");\n  }\n  return 0;\n}",
    "#include <stdio.h>\n\nvoid enterData(int firstMatrix[][10], int secondMatrix[][10], int rowFirst, int columnFirst, int rowSecond, int columnSecond);\nvoid multiplyMatrices(int firstMatrix[][10], int secondMatrix[][10], int multResult[][10], int rowFirst, int columnFirst, int rowSecond, int columnSecond);\nvoid display(int mult[][10], int rowFirst, int columnSecond);\n\nint main()\n{\n	int firstMatrix[10][10], secondMatrix[10][10], mult[10][10], rowFirst, columnFirst, rowSecond, columnSecond, i, j, k;\n\n	printf(\"Enter rows and column for first matrix: \");\n	scanf(\"%d %d\", &rowFirst, &columnFirst);\n\n	printf(\"Enter rows and column for second matrix: \");\n	scanf(\"%d %d\", &rowSecond, &columnSecond);\n\n	// If colum of first matrix in not equal to row of second matrix, asking user to enter the size of matrix again.\n	while (columnFirst != rowSecond)\n	{\n		printf(\"Error! column of first matrix not equal to row of second.\\n\");\n		printf(\"Enter rows and column for first matrix: \");\n		scanf(\"%d%d\", &rowFirst, &columnFirst);\n		printf(\"Enter rows and column for second matrix: \");\n		scanf(\"%d%d\", &rowSecond, &columnSecond);\n	}\n\n	// Function to take matrices data\n        enterData(firstMatrix, secondMatrix, rowFirst, columnFirst, rowSecond, columnSecond);\n\n        // Function to multiply two matrices.\n        multiplyMatrices(firstMatrix, secondMatrix, mult, rowFirst, columnFirst, rowSecond, columnSecond);\n\n        // Function to display resultant matrix after multiplication.\n        display(mult, rowFirst, columnSecond);\n\n	return 0;\n}\n\nvoid enterData(int firstMatrix[][10], int secondMatrix[][10], int rowFirst, int columnFirst, int rowSecond, int columnSecond)\n{\n	int i, j;\n	printf(\"\\nEnter elements of matrix 1:\\n\");\n	for(i = 0; i < rowFirst; ++i)\n	{\n		for(j = 0; j < columnFirst; ++j)\n		{\n			printf(\"Enter elements a%d%d: \", i + 1, j + 1);\n			scanf(\"%d\", &firstMatrix[i][j]);\n		}\n	}\n\n	printf(\"\\nEnter elements of matrix 2:\\n\");\n	for(i = 0; i < rowSecond; ++i)\n	{\n		for(j = 0; j < columnSecond; ++j)\n		{\n			printf(\"Enter elements b%d%d: \", i + 1, j + 1);\n			scanf(\"%d\", &secondMatrix[i][j]);\n		}\n	}\n}\n\nvoid multiplyMatrices(int firstMatrix[][10], int secondMatrix[][10], int mult[][10], int rowFirst, int columnFirst, int rowSecond, int columnSecond)\n{\n	int i, j, k;\n\n	// Initializing elements of matrix mult to 0.\n	for(i = 0; i < rowFirst; ++i)\n	{\n		for(j = 0; j < columnSecond; ++j)\n		{\n			mult[i][j] = 0;\n		}\n	}\n\n	// Multiplying matrix firstMatrix and secondMatrix and storing in array mult.\n	for(i = 0; i < rowFirst; ++i)\n	{\n		for(j = 0; j < columnSecond; ++j)\n		{\n			for(k=0; k<columnFirst; ++k)\n			{\n				mult[i][j] += firstMatrix[i][k] * secondMatrix[k][j];\n			}\n		}\n	}\n}\n\nvoid display(int mult[][10], int rowFirst, int columnSecond)\n{\n	int i, j;\n	printf(\"\\nOutput Matrix:\\n\");\n	for(i = 0; i < rowFirst; ++i)\n	{\n		for(j = 0; j < columnSecond; ++j)\n		{\n			printf(\"%d  \", mult[i][j]);\n			if(j == columnSecond - 1)\n				printf(\"\\n\\n\");\n		}\n	}\n}",
    "#include <stdio.h>\nint main() {\n    int data[5];\n\n    printf(\"Enter elements: \");\n    for (int i = 0; i < 5; ++i)\n        scanf(\"%d\", data + i);\n\n    printf(\"You entered: \\n\");\n    for (int i = 0; i < 5; ++i)\n        printf(\"%d\\n\", *(data + i));\n    return 0;\n}",
    "#include <stdio.h>\nvoid cyclicSwap(int *a, int *b, int *c);\nint main() {\n    int a, b, c;\n\n    printf(\"Enter a, b and c respectively: \");\n    scanf(\"%d %d %d\", &a, &b, &c);\n\n    printf(\"Value before swapping:\\n\");\n    printf(\"a = %d \\nb = %d \\nc = %d\\n\", a, b, c);\n\n    cyclicSwap(&a, &b, &c);\n\n    printf(\"Value after swapping:\\n\");\n    printf(\"a = %d \\nb = %d \\nc = %d\", a, b, c);\n\n    return 0;\n}\n\nvoid cyclicSwap(int *n1, int *n2, int *n3) {\n    int temp;\n    // swapping in cyclic order\n    temp = *n2;\n    *n2 = *n1;\n    *n1 = *n3;\n    *n3 = temp;\n}",
    "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n\n  int n;\n  double *data;\n  printf(\"Enter the total number of elements: \");\n  scanf(\"%d\", &n);\n\n  // Allocating memory for n elements\n  data = (double *)calloc(n, sizeof(double));\n  if (data == NULL) {\n    printf(\"Error!!! memory not allocated.\");\n    exit(0);\n  }\n\n  // Storing numbers entered by the user.\n  for (int i = 0; i < n; ++i) {\n    printf(\"Enter number%d: \", i + 1);\n    scanf(\"%lf\", data + i);\n  }\n\n  // Finding the largest number\n  for (int i = 1; i < n; ++i) {\n    if (*data < *(data + i)) {\n      *data = *(data + i);\n    }\n  }\n  printf(\"Largest number = %.2lf\", *data);\n\n  free(data);\n\n  return 0;\n}",
    "#include <stdio.h>\nint main() {\n    char str[1000], ch;\n    int count = 0;\n\n    printf(\"Enter a string: \");\n    fgets(str, sizeof(str), stdin);\n\n    printf(\"Enter a character to find its frequency: \");\n    scanf(\"%c\", &ch);\n\n    for (int i = 0; str[i] != '\\0'; ++i) {\n        if (ch == str[i])\n            ++count;\n    }\n\n    printf(\"Frequency of %c = %d\", ch, count);\n    return 0;\n}",
    "#include <ctype.h>\n#include <stdio.h>\nint main() {\n\n  char line[150];\n  int vowels, consonant, digit, space;\n\n  // initialize all variables to 0\n  vowels = consonant = digit = space = 0;\n\n  // get full line of string input\n  printf(\"Enter a line of string: \");\n  fgets(line, sizeof(line), stdin);\n\n  // loop through each character of the string\n  for (int i = 0; line[i] != '\\0'; ++i) {\n\n    // convert character to lowercase\n    line[i] = tolower(line[i]);\n\n    // check if the character is a vowel\n    if (line[i] == 'a' || line[i] == 'e' || line[i] == 'i' ||\n        line[i] == 'o' || line[i] == 'u') {\n\n      // increment value of vowels by 1\n      ++vowels;\n    }\n\n    // if it is not a vowel and if it is an alphabet, it is a consonant\n    else if ((line[i] >= 'a' && line[i] <= 'z')) {\n      ++consonant;\n    }\n\n    // check if the character is a digit\n    else if (line[i] >= '0' && line[i] <= '9') {\n      ++digit;\n    }\n\n    // check if the character is an empty space\n    else if (line[i] == ' ') {\n      ++space;\n    }\n  }\n\n  printf(\"Vowels: %d\", vowels);\n  printf(\"\\nConsonants: %d\", consonant);\n  printf(\"\\nDigits: %d\", digit);\n  printf(\"\\nWhite spaces: %d\", space);\n\n  return 0;\n}",
    "#include <stdio.h>\nint main() {\n   char line[150];\n   \n   printf(\"Enter a string: \");\n   fgets(line, sizeof(line), stdin); // take input\n\n   for (int i = 0, j; line[i] != '\\0'; ++i) {\n\n      // enter the loop if the character is not an alphabet\n      // and not the null character\n      while (!(line[i] >= 'a' && line[i] <= 'z') && !(line[i] >= 'A' && line[i] <= 'Z') && !(line[i] == '\\0')) {\n         for (j = i; line[j] != '\\0'; ++j) {\n\n            // if jth element of line is not an alphabet,\n            // assign the value of (j+1)th element to the jth element\n            line[j] = line[j + 1];\n         }\n         line[j] = '\\0';\n      }\n   }\n   printf(\"Output String: \");\n   puts(line);\n   return 0;\n}",
    "#include <stdio.h>\nint main() {\n  char s1[100] = \"programming \", s2[] = \"is awesome\";\n  int length, j;\n\n  // store length of s1 in the length variable\n  length = 0;\n  while (s1[length] != '\\0') {\n    ++length;\n  }\n\n  // concatenate s2 to s1\n  for (j = 0; s2[j] != '\\0'; ++j, ++length) {\n    s1[length] = s2[j];\n  }\n\n  // terminating the s1 string\n  s1[length] = '\\0';\n\n  printf(\"After concatenation: \");\n  puts(s1);\n\n  return 0;\n}",
    "#include <stdio.h>\nint main() {\n    char s1[100], s2[100], i;\n    printf(\"Enter string s1: \");\n    fgets(s1, sizeof(s1), stdin);\n\n    for (i = 0; s1[i] != '\\0'; ++i) {\n        s2[i] = s1[i];\n    }\n\n    s2[i] = '\\0';\n    printf(\"String s2: %s\", s2);\n    return 0;\n}",
    "#include <stdio.h>\n#include <string.h>\n\nint main() {\n   char str[5][50], temp[50];\n   printf(\"Enter 5 words: \");\n\n   // Getting strings input\n   for (int i = 0; i < 5; ++i) {\n      fgets(str[i], sizeof(str[i]), stdin);\n   }\n\n   // storing strings in the lexicographical order\n   for (int i = 0; i < 5; ++i) {\n      for (int j = i + 1; j < 5; ++j) {\n\n         // swapping strings if they are not in the lexicographical order\n         if (strcmp(str[i], str[j]) > 0) {\n            strcpy(temp, str[i]);\n            strcpy(str[i], str[j]);\n            strcpy(str[j], temp);\n         }\n      }\n   }\n\n   printf(\"\\nIn the lexicographical order: \\n\");\n   for (int i = 0; i < 5; ++i) {\n      fputs(str[i], stdout);\n   }\n   return 0;\n}",
    "#include <stdio.h>\nstruct student {\n    char name[50];\n    int roll;\n    float marks;\n} s;\n\nint main() {\n    printf(\"Enter information:\\n\");\n    printf(\"Enter name: \");\n    fgets(s.name, sizeof(s.name), stdin);\n\n    printf(\"Enter roll number: \");\n    scanf(\"%d\", &s.roll);\n    printf(\"Enter marks: \");\n    scanf(\"%f\", &s.marks);\n\n    printf(\"Displaying Information:\\n\");\n    printf(\"Name: \");\n    printf(\"%s\", s.name);\n    printf(\"Roll number: %d\\n\", s.roll);\n    printf(\"Marks: %.1f\\n\", s.marks);\n\n    return 0;\n}",
    "#include <stdio.h>\n\nstruct Distance {\n   int feet;\n   float inch;\n} d1, d2, result;\n\nint main() {\n   // take first distance input\n   printf(\"Enter 1st distance\\n\");\n   printf(\"Enter feet: \");\n   scanf(\"%d\", &d1.feet);\n   printf(\"Enter inch: \");\n   scanf(\"%f\", &d1.inch);\n \n   // take second distance input\n   printf(\"\\nEnter 2nd distance\\n\");\n   printf(\"Enter feet: \");\n   scanf(\"%d\", &d2.feet);\n   printf(\"Enter inch: \");\n   scanf(\"%f\", &d2.inch);\n   \n   // adding distances\n   result.feet = d1.feet + d2.feet;\n   result.inch = d1.inch + d2.inch;\n\n   // convert inches to feet if greater than 12\n   while (result.inch >= 12.0) {\n      result.inch = result.inch - 12.0;\n      ++result.feet;\n   }\n   printf(\"\\nSum of distances = %d\\'-%.1f\\\"\", result.feet, result.inch);\n   return 0;\n}",
    "#include <stdio.h>\ntypedef struct complex {\n    float real;\n    float imag;\n} complex;\n\ncomplex add(complex n1, complex n2);\n\nint main() {\n    complex n1, n2, result;\n\n    printf(\"For 1st complex number \\n\");\n    printf(\"Enter the real and imaginary parts: \");\n    scanf(\"%f %f\", &n1.real, &n1.imag);\n    printf(\"\\nFor 2nd complex number \\n\");\n    printf(\"Enter the real and imaginary parts: \");\n    scanf(\"%f %f\", &n2.real, &n2.imag);\n\n    result = add(n1, n2);\n\n    printf(\"Sum = %.1f + %.1fi\", result.real, result.imag);\n    return 0;\n}\n\ncomplex add(complex n1, complex n2) {\n    complex temp;\n    temp.real = n1.real + n2.real;\n    temp.imag = n1.imag + n2.imag;\n    return (temp);\n}",
    "#include <stdio.h>\nstruct TIME {\n   int seconds;\n   int minutes;\n   int hours;\n};\n\nvoid differenceBetweenTimePeriod(struct TIME t1,\n                                 struct TIME t2,\n                                 struct TIME *diff);\n\nint main() {\n   struct TIME startTime, stopTime, diff;\n\n   printf(\"Enter the start time. \\n\");\n   printf(\"Enter hours, minutes and seconds: \");\n   scanf(\"%d %d %d\", &startTime.hours,\n         &startTime.minutes,\n         &startTime.seconds);\n\n   printf(\"Enter the stop time. \\n\");\n   printf(\"Enter hours, minutes and seconds: \");\n   scanf(\"%d %d %d\", &stopTime.hours,\n         &stopTime.minutes,\n         &stopTime.seconds);\n\n   // Difference between start and stop time\n   differenceBetweenTimePeriod(startTime, stopTime, &diff);\n   printf(\"\\nTime Difference: %d:%d:%d - \", startTime.hours,\n          startTime.minutes,\n          startTime.seconds);\n   printf(\"%d:%d:%d \", stopTime.hours,\n          stopTime.minutes,\n          stopTime.seconds);\n   printf(\"= %d:%d:%d\\n\", diff.hours,\n          diff.minutes,\n          diff.seconds);\n   return 0;\n}\n\n// Computes difference between time periods\nvoid differenceBetweenTimePeriod(struct TIME start,\n                                 struct TIME stop,\n                                 struct TIME *diff) {\n   while (start.seconds > stop.seconds) {\n      --stop.minutes;\n      stop.seconds += 60;\n   }\n   diff->seconds = stop.seconds - start.seconds;\n   while (start.minutes > stop.minutes) {\n      --stop.hours;\n      stop.minutes += 60;\n   }\n   diff->minutes = stop.minutes - start.minutes;\n   diff->hours = stop.hours - start.hours;\n\n   if(diff->hours < 0){\n      diff->hours += 24; \n   }\n}",
    "#include <stdio.h>\nstruct student {\n    char firstName[50];\n    int roll;\n    float marks;\n} s[5];\n\nint main() {\n    int i;\n    printf(\"Enter information of students:\\n\");\n\n    // storing information\n    for (i = 0; i < 5; ++i) {\n        s[i].roll = i + 1;\n        printf(\"\\nFor roll number%d,\\n\", s[i].roll);\n        printf(\"Enter first name: \");\n        scanf(\"%s\", s[i].firstName);\n        printf(\"Enter marks: \");\n        scanf(\"%f\", &s[i].marks);\n    }\n    printf(\"Displaying Information:\\n\\n\");\n\n    // displaying information\n    for (i = 0; i < 5; ++i) {\n        printf(\"\\nRoll number: %d\\n\", i + 1);\n        printf(\"First name: \");\n        puts(s[i].firstName);\n        printf(\"Marks: %.1f\", s[i].marks);\n        printf(\"\\n\");\n    }\n    return 0;\n}",
    "#include <stdio.h>\n#include <stdlib.h>\nstruct course {\n  int marks;\n  char subject[30];\n};\n\nint main() {\n  struct course *ptr;\n  int noOfRecords;\n  printf(\"Enter the number of records: \");\n  scanf(\"%d\", &noOfRecords);\n\n  // Memory allocation for noOfRecords structures\n  ptr = (struct course *)malloc(noOfRecords * sizeof(struct course));\n  for (int i = 0; i < noOfRecords; ++i) {\n    printf(\"Enter subject and marks:\\n\");\n    scanf(\"%s %d\", (ptr + i)->subject, &(ptr + i)->marks);\n  }\n\n  printf(\"Displaying Information:\\n\");\n  for (int i = 0; i < noOfRecords; ++i) {\n    printf(\"%s\\t%d\\n\", (ptr + i)->subject, (ptr + i)->marks);\n  }\n\n  free(ptr);\n\n  return 0;\n}",
    "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    char sentence[1000];\n\n    // creating file pointer to work with files\n    FILE *fptr;\n\n    // opening file in writing mode\n    fptr = fopen(\"program.txt\", \"w\");\n\n    // exiting program \n    if (fptr == NULL) {\n        printf(\"Error!\");\n        exit(1);\n    }\n    printf(\"Enter a sentence:\\n\");\n    fgets(sentence, sizeof(sentence), stdin);\n    fprintf(fptr, \"%s\", sentence);\n    fclose(fptr);\n    return 0;\n}",
    "#include <stdio.h>\n#include <stdlib.h> // For exit() function\nint main() {\n    char c[1000];\n    FILE *fptr;\n    if ((fptr = fopen(\"program.txt\", \"r\")) == NULL) {\n        printf(\"Error! File cannot be opened.\");\n        // Program exits if the file pointer returns NULL.\n        exit(1);\n    }\n\n    // reads text until newline is encountered\n    fscanf(fptr, \"%[^\\n]\", c);\n    printf(\"Data from the file:\\n%s\", c);\n    fclose(fptr);\n\n    return 0;\n}",
    "#include <stdio.h>\nint main() {\n    FILE *fp;\n    int c;\n   \n    // open the current input file\n    fp = fopen(__FILE__,\"r\");\n\n    do {\n         c = getc(fp);   // read character \n         putchar(c);     // display character\n    }\n    while(c != EOF);  // loop until the end of file is reached\n    \n    fclose(fp);\n    return 0;\n}",
    "void bubble_sort_variant(int arr[], int n, int ascending) {\n    for (int i = 0; i < n-1; i++) {\n        int swapped = 0;\n        for (int j = 0; j < n-i-1; j++) {\n            int condition = ascending ? (arr[j] > arr[j+1]) : (arr[j] < arr[j+1]);\n            if (condition) {\n                int temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n                swapped = 1;\n            }\n        }\n        if (!swapped) break;\n    }\n}",
    "void selection_sort_variant(int arr[], int n) {\n    for (int i = 0; i < n-1; i++) {\n        int min_idx = i;\n        for (int j = i+1; j < n; j++) {\n            if (arr[j] < arr[min_idx]) {\n                min_idx = j;\n            }\n        }\n        int temp = arr[min_idx];\n        arr[min_idx] = arr[i];\n        arr[i] = temp;\n    }\n}",
    "int binary_search_variant(int arr[], int n, int target) {\n    int left = 0, right = n - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        }\n        if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}",
    "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int* data;\n    int front;\n    int rear;\n    int capacity;\n} Queue;\n\nQueue* create_queue(int capacity) {\n    Queue* q = (Queue*)malloc(sizeof(Queue));\n    q->data = (int*)malloc(capacity * sizeof(int));\n    q->front = 0;\n    q->rear = -1;\n    q->capacity = capacity;\n    return q;\n}\n\nvoid enqueue(Queue* q, int item) {\n    if (q->rear < q->capacity - 1) {\n        q->data[++q->rear] = item;\n    }\n}\n\nint dequeue(Queue* q) {\n    if (q->front <= q->rear) {\n        return q->data[q->front++];\n    }\n    return -1;\n}",
    "#include <string.h>\n\nvoid string_reverse(char* str) {\n    int len = strlen(str);\n    for (int i = 0; i < len/2; i++) {\n        char temp = str[i];\n        str[i] = str[len-1-i];\n        str[len-1-i] = temp;\n    }\n}\n\nint string_length(char* str) {\n    int count = 0;\n    while (str[count] != '\\0') {\n        count++;\n    }\n    return count;\n}\n\nvoid string_copy(char* dest, char* src) {\n    int i = 0;\n    while (src[i] != '\\0') {\n        dest[i] = src[i];\n        i++;\n    }\n    dest[i] = '\\0';\n}",
]
