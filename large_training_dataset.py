# Large-scale training dataset for Vec2Vec code translation
# Generated on 2025-07-09 15:53:11
# Contains 44 Python and 45 C snippets

LARGE_PYTHON_SAMPLES = [
    "def binary_search(l, value):\n    low = 0\n    high = len(l)-1\n    while low <= high: \n        mid = (low+high)//2\n        if l[mid] > value: high = mid-1\n        elif l[mid] < value: low = mid+1\n        else: return mid\n    return -1",
    "def binary_search(l, value, low = 0, high = -1):\n    if not l: return -1\n    if(high == -1): high = len(l)-1\n    if low >= high:\n        if l[low] == value: return low\n        else: return -1\n    mid = (low+high)//2\n    if l[mid] > value: return binary_search(l, value, low, mid-1)\n    elif l[mid] < value: return binary_search(l, value, mid+1, high)\n    else: return mid",
    "def binary_search(l, value):\n    low = 0\n    high = len(l)-1\n    while low + 1 < high:\n        mid = (low+high)//2\n        if l[mid] > value:\n            high = mid\n        elif l[mid] < value:\n            low = mid\n        else:\n            return mid\n    return high if abs(l[high] - value) < abs(l[low] - value) else low",
    "def fibIter(n):\n    if n < 2:\n        return n\n    fibPrev = 1\n    fib = 1\n    for _ in range(2, n):\n        fibPrev, fib = fib, fib + fibPrev\n    return fib",
    "def fibRec(n):\n    if n < 2:\n        return n\n    else:\n        return fibRec(n-1) + fibRec(n-2)",
    "def fibFastRec(n):\n    def fib(prvprv, prv, c):\n        if c < 1: \n            return prvprv\n        else: \n            return fib(prv, prvprv + prv, c - 1) \n    return fib(0, 1, n)",
    "def fibGen(n):\n    a, b = 0, 1\n    while n>0:\n        yield a\n        a, b, n = b, a+b, n-1",
    "def prevPowTwo(n):\n    'Gets the power of two that is less than or equal to the given input'\n    if ((n & -n) == n):\n        return n\n    else:\n        n -= 1\n        n |= n >> 1\n        n |= n >> 2\n        n |= n >> 4\n        n |= n >> 8\n        n |= n >> 16\n        n += 1\n        return (n/2)\n\ndef crazyFib(n):\n    'Crazy fast fibonacci number calculation'\n    powTwo = prevPowTwo(n)\n    \n    q = r = i = 1\n    s = 0\n    \n    while(i < powTwo):\n        i *= 2\n        q, r, s = q*q + r*r, r * (q + s), (r*r + s*s)\n        \n    while(i < n):\n        i += 1\n        q, r, s = q+r, q, r\n        \n    return q",
    "def fib(n, c={0:1, 1:1}):\n    if n not in c:\n        x = n // 2\n        c[n] = fib(x-1) * fib(n-x-1) + fib(x) * fib(n - x)\n    return c[n]\n\nfib(10000000)  # calculating it takes a few seconds, printing it takes eons",
    "F = {0: 0, 1: 1, 2: 1}\ndef fib(n):\n    if n in F:\n        return F[n]\n    f1 = fib(n // 2 + 1)\n    f2 = fib((n - 1) // 2)\n    F[n] = (f1 * f1 + f2 * f2 if n & 1 else f1 * f1 - f2 * f2)\n    return F[n]",
    "from itertools import islice\n\ndef fib():\n    yield 0\n    yield 1\n    a, b = fib(), fib()\n    next(b)\n    while True:\n        yield next(a)+next(b)\n \nprint(tuple(islice(fib(), 10)))",
    "'''Fibonacci accumulation'''\n\nfrom itertools import accumulate\n\n# fibs :: Integer :: [Integer]\ndef fibs(n):\n    '''An accumulation of the first n integers in\n       the Fibonacci series. The accumulator is a\n       pair of the two preceding numbers.\n    '''\n    return [\n        a\n        for a, b in accumulate(\n            range(1, n),  # we don't actually use these numbers\n            lambda acc, _: (acc[1],  sum(acc)),\n            initial = (0, 1)\n        )\n    ]\n\n# MAIN ---\nif __name__ == '__main__':\n    print(f'First twenty: {fibs(20)}')",
    "'''Nth Fibonacci term (by folding)'''\n\nfrom functools import reduce\n\n# nthFib :: Integer -> Integer\ndef nthFib(n):\n    '''Nth integer in the Fibonacci series.'''\n    return reduce(\n        lambda acc, _: (acc[1], sum(acc)),\n        range(1, n),\n        (0, 1)\n    )[0]\n\n# MAIN ---\nif __name__ == '__main__':\n    n = 1000\n    print(f'{n}th term: {nthFib(n)}')",
    "fibseq = [1,1,]\nfiblength = 21\nfor x in range(1,fiblength-1):\n	xcount = fibseq[x-1] + fibseq[x]\n	fibseq.append(xcount)\nprint(xcount)",
    "def factorial(n):\n    result = 1\n    for i in range(1, n+1):\n        result *= i\n    return result",
    "from operator import mul\nfrom functools import reduce\n\ndef factorial(n):\n    return reduce(mul, range(1,n+1), 1)",
    "from itertools import (accumulate, chain)\nfrom operator import mul\n\n# factorial :: Integer\ndef factorial(n):\n    return list(\n        accumulate(chain([1], range(1, 1 + n)), mul)\n    )[-1]",
    "from itertools import (accumulate, chain)\nfrom operator import mul\n\n# factorials :: [Integer]\ndef factorials(n):\n    return list(\n        accumulate(chain([1], range(1, 1 + n)), mul)\n    )\n\nprint(factorials(5))\n\n# -> [1, 1, 2, 6, 24, 120]",
    "from numpy import prod\n\ndef factorial(n):\n    return prod(range(1, n + 1), dtype=int)",
    "def factorial(n):\n    z=1\n    if n>1:\n        z=n*factorial(n-1)\n    return z",
    "for i in range(6):\n    print(i, factorial(i))\n   \n1\n1\n2\n6\n24\n120",
    "def gcd_bin(u, v):\n    u, v = abs(u), abs(v) # u >= 0, v >= 0\n    if u < v:\n        u, v = v, u # u >= v >= 0\n    if v == 0:\n        return u\n   \n    # u >= v > 0\n    k = 1\n    while u & 1 == 0 and v & 1 == 0: # u, v - even\n        u >>= 1; v >>= 1\n        k <<= 1\n       \n    t = -v if u & 1 else u\n    while t:\n        while t & 1 == 0:\n            t >>= 1\n        if t > 0:\n            u = t\n        else:\n            v = -t\n        t = u - v\n    return u * k",
    "def selection_sort(lst):\n    for i, e in enumerate(lst):\n        mn = min(range(i,len(lst)), key=lst.__getitem__)\n        lst[i], lst[mn] = lst[mn], e\n    return lst",
    "def insertion_sort(L):\n    for i in xrange(1, len(L)):\n        j = i-1 \n        key = L[i]\n        while j >= 0 and L[j] > key:\n           L[j+1] = L[j]\n           j -= 1\n        L[j+1] = key",
    "def insertion_sort(L):\n    for i, value in enumerate(L):\n        for j in range(i - 1, -1, -1):\n            if L[j] > value:\n                L[j + 1] = L[j]\n                L[j] = value",
    "# Creating a Dictionary\nDict = {'Name': 'Geeks', 1: [1, 2, 3, 4]}\nprint(\"Creating Dictionary: \")\nprint(Dict)\n\n# accessing a element using key \nprint(\"Accessing a element using key:\") \nprint(Dict['Name']) \n\n# accessing a element using get() \n# method \nprint(\"Accessing a element using get:\") \nprint(Dict.get(1)) \n\n# creation using Dictionary comprehension\nmyDict = {x: x**2 for x in [1,2,3,4,5]}\nprint(myDict)",
    "# Creating a Set with  \n# a mixed type of values \n# (Having numbers and strings) \nSet = set([1, 2, 'Geeks', 4, 'For', 6, 'Geeks']) \nprint(\"\\nSet with the use of Mixed Values\") \nprint(Set) \n\n# Accessing element using \n# for loop \nprint(\"\\nElements of set: \") \nfor i in Set: \n    print(i, end =\" \") \nprint()\n\n# Checking the element \n# using in keyword \nprint(\"Geeks\" in Set)",
    "from collections import Counter\n  \n# With sequence of items \nprint(Counter(['B','B','A','B','C','A','B','B','A','C']))\n  \n# with dictionary\ncount = Counter({'A':3, 'B':5, 'C':2})\nprint(count)\n\ncount.update(['A', 1])\nprint(count)",
    "from collections import OrderedDict\n\nprint(\"Before deleting:\\n\")\nod = OrderedDict()\nod['a'] = 1\nod['b'] = 2\nod['c'] = 3\nod['d'] = 4\n\nfor key, value in od.items():\n    print(key, value)\n\nprint(\"\\nAfter deleting:\\n\")\nod.pop('c')\nfor key, value in od.items():\n    print(key, value)\n\nprint(\"\\nAfter re-inserting:\\n\")\nod['c'] = 3\nfor key, value in od.items():\n    print(key, value)",
    "from collections import defaultdict\n\n# Defining the dict\nd = defaultdict(int)\n    \nL = [1, 2, 3, 4, 2, 4, 1, 2]\n    \n# Iterate through the list\n# for keeping the count\nfor i in L:\n        \n    # The default value is 0\n    # so there is no need to\n    # enter the key first\n    d[i] += 1\n        \nprint(d)",
    "from collections import ChainMap\n\nd1 = {'a': 1, 'b': 2}\nd2 = {'c': 3, 'd': 4}\nd3 = {'e': 5, 'f': 6}\n    \n# Defining the chainmap\nc = ChainMap(d1, d2, d3)\nprint(c)\n\nprint(c['a'])\nprint(c['g'])",
    "from collections import namedtuple\n    \n# Declaring namedtuple()\nStudent = namedtuple('Student',['name','age','DOB'])\n    \n# Adding values\nS = Student('Nandini','19','2541997')\n    \n# Access using index\nprint (\"The Student age using index is : \",end =\"\")\nprint (S[1])\n    \n# Access using name\nprint (\"The Student name using keyname is : \",end =\"\")\nprint (S.name)",
    "# importing \"collections\" for deque operations\nimport collections\n\n# initializing deque\nde = collections.deque([1,2,3])\n\n# using append() to insert element at right end\n# inserts 4 at the end of deque\nde.append(4)\n\n# printing modified deque\nprint(\"The deque after appending at right is : \")\nprint(de)\n\n# using appendleft() to insert element at left end\n# inserts 6 at the beginning of deque\nde.appendleft(6)\n\n# printing modified deque\nprint(\"The deque after appending at left is : \")\nprint(de)\n\n# using pop() to delete element from right end\n# deletes 4 from the right end of deque\nde.pop()\n\n# printing modified deque\nprint(\"The deque after deleting from right is : \")\nprint(de)\n\n# using popleft() to delete element from left end\n# deletes 6 from the left end of deque\nde.popleft()\n\n# printing modified deque\nprint(\"The deque after deleting from left is : \")\nprint(de)",
    "# Program to check if a number is prime or not\n\nnum = 29\n\n# To take input from the user\n#num = int(input(\"Enter a number: \"))\n\n# define a flag variable\nflag = False\n\nif num == 0 or num == 1:\n    print(num, \"is not a prime number\")\nelif num > 1:\n    # check for factors\n    for i in range(2, num):\n        if (num % i) == 0:\n            # if factor is found, set flag to True\n            flag = True\n            # break out of loop\n            break\n\n    # check if flag is True\n    if flag:\n        print(num, \"is not a prime number\")\n    else:\n        print(num, \"is a prime number\")",
    "# Python program to find the factorial of a number provided by the user.\n\n# change the value for a different result\nnum = 7\n\n# To take input from the user\n#num = int(input(\"Enter a number: \"))\n\nfactorial = 1\n\n# check if the number is negative, positive or zero\nif num < 0:\n   print(\"Sorry, factorial does not exist for negative numbers\")\nelif num == 0:\n   print(\"The factorial of 0 is 1\")\nelse:\n   for i in range(1,num + 1):\n       factorial = factorial*i\n   print(\"The factorial of\",num,\"is\",factorial)",
    "# Program to display the Fibonacci sequence up to n-th term\n\nnterms = int(input(\"How many terms? \"))\n\n# first two terms\nn1, n2 = 0, 1\ncount = 0\n\n# check if the number of terms is valid\nif nterms <= 0:\n   print(\"Please enter a positive integer\")\n# if there is only one term, return n1\nelif nterms == 1:\n   print(\"Fibonacci sequence upto\",nterms,\":\")\n   print(n1)\n# generate fibonacci sequence\nelse:\n   print(\"Fibonacci sequence:\")\n   while count < nterms:\n       print(n1)\n       nth = n1 + n2\n       # update values\n       n1 = n2\n       n2 = nth\n       count += 1",
    "# Python program to check if year is a leap year or not\n\nyear = 2000\n\n# To get year (integer input) from the user\n# year = int(input(\"Enter a year: \"))\n\n# divided by 100 means century year (ending with 00)\n# century year divided by 400 is leap year\nif (year % 400 == 0) and (year % 100 == 0):\n    print(\"{0} is a leap year\".format(year))\n\n# not divided by 100 means not a century year\n# year divided by 4 is a leap year\nelif (year % 4 ==0) and (year % 100 != 0):\n    print(\"{0} is a leap year\".format(year))\n\n# if not divided by both 400 (century year) and 4 (not century year)\n# year is not leap year\nelse:\n    print(\"{0} is not a leap year\".format(year))",
    "# This function adds two numbers\ndef add(x, y):\n    return x + y\n\n# This function subtracts two numbers\ndef subtract(x, y):\n    return x - y\n\n# This function multiplies two numbers\ndef multiply(x, y):\n    return x * y\n\n# This function divides two numbers\ndef divide(x, y):\n    return x / y\n\nprint(\"Select operation.\")\nprint(\"1.Add\")\nprint(\"2.Subtract\")\nprint(\"3.Multiply\")\nprint(\"4.Divide\")\n\nwhile True:\n    # take input from the user\n    choice = input(\"Enter choice(1/2/3/4): \")\n\n    # check if choice is one of the four options\n    if choice in ('1', '2', '3', '4'):\n        try:\n            num1 = float(input(\"Enter first number: \"))\n            num2 = float(input(\"Enter second number: \"))\n        except ValueError:\n            print(\"Invalid input. Please enter a number.\")\n            continue\n\n        if choice == '1':\n            print(num1, \"+\", num2, \"=\", add(num1, num2))\n\n        elif choice == '2':\n            print(num1, \"-\", num2, \"=\", subtract(num1, num2))\n\n        elif choice == '3':\n            print(num1, \"*\", num2, \"=\", multiply(num1, num2))\n\n        elif choice == '4':\n            print(num1, \"/\", num2, \"=\", divide(num1, num2))\n        \n        # check if user wants another calculation\n        # break the while loop if answer is no\n        next_calculation = input(\"Let's do next calculation? (yes/no): \")\n        if next_calculation == \"no\":\n          break\n    else:\n        print(\"Invalid Input\")",
    "# Find square root of real or complex numbers\n# Importing the complex math module\nimport cmath\n\nnum = 1+2j\n\n# To take input from the user\n#num = eval(input('Enter a number: '))\n\nnum_sqrt = cmath.sqrt(num)\nprint('The square root of {0} is {1:0.3f}+{2:0.3f}j'.format(num ,num_sqrt.real,num_sqrt.imag))",
    "def bubble_sort_variant(arr, ascending=True):\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        for j in range(0, n-i-1):\n            condition = arr[j] > arr[j+1] if ascending else arr[j] < arr[j+1]\n            if condition:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                swapped = True\n        if not swapped:\n            break\n    return arr",
    "def selection_sort_variant(arr, key=None):\n    n = len(arr)\n    for i in range(n):\n        min_idx = i\n        for j in range(i+1, n):\n            val_j = arr[j] if key is None else key(arr[j])\n            val_min = arr[min_idx] if key is None else key(arr[min_idx])\n            if val_j < val_min:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr",
    "def binary_search_variant(arr, target, left=0, right=None):\n    if right is None:\n        right = len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
    "class SimpleQueue:\n    def __init__(self, maxsize=None):\n        self.items = []\n        self.maxsize = maxsize\n    \n    def enqueue(self, item):\n        if self.maxsize and len(self.items) >= self.maxsize:\n            raise Exception('Queue is full')\n        self.items.append(item)\n    \n    def dequeue(self):\n        if not self.items:\n            raise Exception('Queue is empty')\n        return self.items.pop(0)\n    \n    def is_empty(self):\n        return len(self.items) == 0",
    "def string_utils(text, operation='reverse'):\n    if operation == 'reverse':\n        return text[::-1]\n    elif operation == 'uppercase':\n        return text.upper()\n    elif operation == 'word_count':\n        return len(text.split())\n    elif operation == 'char_frequency':\n        freq = {}\n        for char in text:\n            freq[char] = freq.get(char, 0) + 1\n        return freq\n    return text",
]

LARGE_C_SAMPLES = [
    "// initially called with low = 0, high = N-1\n  BinarySearch(A[0..N-1], value, low, high) {\n      // invariants: value > A[i] for all i < low\n                     value < A[i] for all i > high\n      if (high < low)\n          return not_found // value would be inserted at index \"low\"\n      mid = (low + high) / 2\n      if (A[mid] > value)\n          return BinarySearch(A, value, low, mid-1)\n      else if (A[mid] < value)\n          return BinarySearch(A, value, mid+1, high)\n      else\n          return mid\n  }",
    "BinarySearch(A[0..N-1], value) {\n      low = 0\n      high = N - 1\n      while (low <= high) {\n          // invariants: value > A[i] for all i < low\n                         value < A[i] for all i > high\n          mid = (low + high) / 2\n          if (A[mid] > value)\n              high = mid - 1\n          else if (A[mid] < value)\n              low = mid + 1\n          else\n              return mid\n      }\n      return not_found // value would be inserted at index \"low\"\n  }",
    "// initially called with low = 0, high = N - 1\n  BinarySearch_Left(A[0..N-1], value, low, high) {\n      // invariants: value > A[i] for all i < low\n                     value <= A[i] for all i > high\n      if (high < low)\n          return low\n      mid = (low + high) / 2\n      if (A[mid] >= value)\n          return BinarySearch_Left(A, value, low, mid-1)\n      else\n          return BinarySearch_Left(A, value, mid+1, high)\n  }",
    "BinarySearch_Left(A[0..N-1], value) {\n      low = 0\n      high = N - 1\n      while (low <= high) {\n          // invariants: value > A[i] for all i < low\n                         value <= A[i] for all i > high\n          mid = (low + high) / 2\n          if (A[mid] >= value)\n              high = mid - 1\n          else\n              low = mid + 1\n      }\n      return low\n  }",
    "// initially called with low = 0, high = N - 1\n  BinarySearch_Right(A[0..N-1], value, low, high) {\n      // invariants: value >= A[i] for all i < low\n                     value < A[i] for all i > high\n      if (high < low)\n          return low\n      mid = (low + high) / 2\n      if (A[mid] > value)\n          return BinarySearch_Right(A, value, low, mid-1)\n      else\n          return BinarySearch_Right(A, value, mid+1, high)\n  }",
    "BinarySearch_Right(A[0..N-1], value) {\n      low = 0\n      high = N - 1\n      while (low <= high) {\n          // invariants: value >= A[i] for all i < low\n                         value < A[i] for all i > high\n          mid = (low + high) / 2\n          if (A[mid] > value)\n              high = mid - 1\n          else\n              low = mid + 1\n      }\n      return low\n  }",
    "on binarySearch(n, theList, l, r)\n    repeat until (l = r)\n        set m to (l + r) div 2\n        if (item m of theList < n) then\n            set l to m + 1\n        else\n            set r to m\n        end if\n    end repeat\n    \n    if (item l of theList is n) then return l\n    return missing value\nend binarySearch\n\non test(n, theList, l, r)\n    set |result| to binarySearch(n, theList, l, r)\n    if (|result| is missing value) then\n        return (n as text) & \" is not in range \" & l & \" thru \" & r & \" of the list\"\n    else\n        return \"The first occurrence of \" & n & \" in range \" & l & \" thru \" & r & \" of the list is at index \" & |result|\n    end if\nend test\n\nset theList to {1, 2, 3, 3, 5, 7, 7, 8, 9, 10, 11, 12}\nreturn test(7, theList, 4, 11) & linefeed & test(7, theList, 7, 12) & linefeed & test(7, theList, 1, 5)",
    "array := \"1,2,4,6,8,9\"\nStringSplit, A, array, `,   ; creates associative array\nMsgBox % x := BinarySearch(A, 4, 1, A0) ; Recursive\nMsgBox % A%x%\nMsgBox % x := BinarySearchI(A, A0, 4)  ; Iterative\nMsgBox % A%x%\n\nBinarySearch(A, value, low, high) { ; A0 contains length of array\n  If (high < low)               ; A1, A2, A3...An are array elements\n    Return not_found\n  mid := Floor((low + high) / 2)\n  If (A%mid% > value) ; A%mid% is automatically global since no such locals are present\n    Return BinarySearch(A, value, low, mid - 1)\n  Else If (A%mid% < value)\n    Return BinarySearch(A, value, mid + 1, high)\n  Else\n    Return mid\n}\n\nBinarySearchI(A, lengthA, value) {\n  low := 0\n  high := lengthA - 1\n  While (low <= high) {\n    mid := Floor((low + high) / 2) ; round to lower integer\n    If (A%mid% > value)   \n      high := mid - 1\n    Else If (A%mid% < value)\n      low := mid + 1\n    Else\n      Return mid\n  }\n  Return not_found\n}",
    "function binary_search(array, value, left, right,       middle) {\n    if (right < left) return 0\n    middle = int((right + left) / 2)\n    if (value == array[middle]) return 1\n    if (value <  array[middle])\n        return binary_search(array, value, left, middle - 1)\n    return binary_search(array, value, middle + 1, right)\n}",
    "function binary_search(array, value, left, right,       middle) {\n    while (left <= right) {\n        middle = int((right + left) / 2)\n        if (value == array[middle]) return 1\n        if (value <  array[middle]) right = middle - 1\n        else                        left  = middle + 1\n    }\n    return 0\n}",
    "rem Binary search\ncls\ndim a(10)\nn% = 10\nfor i% = 0 to 9 : read a(i%) : next i%\nrem Sorted data\ndata -31,0,1,2,2,4,65,83,99,782\nx = 2 : gosub 280\ngosub 230\nx = 5 : gosub 280\ngosub 230\nend\nrem Print result\nprint x;\nif indx% >= 0 then print \"is at index \";str$(indx%);\".\" else print \"is not found.\"\nreturn\nrem Binary search algorithm\nrem N% - number of elements; X - searched element; Result: INDX% - index of X\nl% = 0 : h% = n%-1 : found% = 0\nwhile (l% <= h%) and  not found%\nm% = l%+int((h%-l%)/2)\nif a(m%) < x then l% = m%+1 else if a(m%) > x then h% = m%-1 else found% = -1\nwend\nif found% = 0 then indx% = -1 else indx% = m%\nreturn",
    "sub floor(n)\n    return int(n + .5)\nend sub\n\nsub binarySearch(list(), value)\n    local low, high, mid\n    \n    low = 1 : high = arraysize(list(), 1)\n\n    while(low <= high)\n        mid = floor((low + high) / 2)\n        if list(mid) > value then\n            high = mid - 1\n        elsif list(mid) < value then\n            low = mid + 1\n        else\n            return mid\n        end if\n    wend\n    return false\nend sub\n\nITEMS = 10e6\n\ndim list(ITEMS)\n\nfor n = 1 to ITEMS\n    list(n) = n\nnext n\n\nprint binarySearch(list(), 3)\nprint peek(\"millisrunning\")",
    "#include <stdio.h>\n\nint bsearch (int *a, int n, int x) {\n    int i = 0, j = n - 1;\n    while (i <= j) {\n        int k = i + ((j - i) / 2);\n        if (a[k] == x) {\n            return k;\n        }\n        else if (a[k] < x) {\n            i = k + 1;\n        }\n        else {\n            j = k - 1;\n        }\n    }\n    return -1;\n}\n\nint bsearch_r (int *a, int x, int i, int j) {\n    if (j < i) {\n        return -1;\n    }\n    int k = i + ((j - i) / 2);\n    if (a[k] == x) {\n        return k;\n    }\n    else if (a[k] < x) {\n        return bsearch_r(a, x, k + 1, j);\n    }\n    else {\n        return bsearch_r(a, x, i, k - 1);\n    }\n}\n\nint main () {\n    int a[] = {-31, 0, 1, 2, 2, 4, 65, 83, 99, 782};\n    int n = sizeof a / sizeof a[0];\n    int x = 2;\n    int i = bsearch(a, n, x);\n    if (i >= 0)  \n      printf(\"%d is at index %d.\\n\", x, i);\n    else\n      printf(\"%d is not found.\\n\", x);\n    x = 5;\n    i = bsearch_r(a, x, 0, n - 1);\n    if (i >= 0)  \n      printf(\"%d is at index %d.\\n\", x, i);\n    else\n      printf(\"%d is not found.\\n\", x);\n    return 0;\n}",
    "//#define UseRecursiveSearch\n\nusing System;\nusing Search;\n\nclass Program {\n  static readonly int[][] tests = {\n    new int[] { },\n    new int[] { 2 },\n    new int[] { 2, 2 },\n    new int[] { 2, 2, 2, 2 },\n    new int[] { 3, 3, 4, 4 },\n    new int[] { 0, 1, 3, 3, 4, 4 },\n    new int[] { 0, 1, 2, 2, 2, 3, 3, 4, 4},\n    new int[] { 0, 1, 1, 2, 2, 2, 3, 3, 4, 4 },\n    new int[] { 0, 1, 1, 1, 1, 2, 2, 3, 3, 4, 4 },\n    new int[] { 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4 },\n    new int[] { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4 },\n  };\n\n  static void Main(string[] args) {\n    var index = 0;\n    foreach (var test in tests) {\n      var join = String.Join(\" \", test);\n      Console.WriteLine($\"test[{index}]: {join}\");\n#if UseRecursiveSearch\n      var glb = test.RecursiveBinarySearchForGLB(2);\n      var lub = test.RecursiveBinarySearchForLUB(2);\n#else\n      var glb = test.BinarySearchForGLB(2);\n      var lub = test.BinarySearchForLUB(2);\n#endif\n      Console.WriteLine($\"glb = {glb}\");\n      Console.WriteLine($\"lub = {lub}\");\n\n      index++;\n    }\n#if DEBUG\n    Console.Write(\"Press Enter\");\n    Console.ReadLine();\n#endif\n  }\n}",
    "template <class T> int binsearch(const T array[], int low, int high, T value) {\n    if (high < low) {\n        return -1;\n    }\n    auto mid = (low + high) / 2;\n    if (value < array[mid]) {\n        return binsearch(array, low, mid - 1, value);\n    } else if (value > array[mid]) {\n        return binsearch(array, mid + 1, high, value);\n    }\n    return mid;\n}\n\n#include <iostream>\nint main()\n{\n  int array[] = {2, 3, 5, 6, 8};\n  int result1 = binsearch(array, 0, sizeof(array)/sizeof(int), 4),\n      result2 = binsearch(array, 0, sizeof(array)/sizeof(int), 8);\n  if (result1 == -1) std::cout << \"4 not found!\" << std::endl;\n  else std::cout << \"4 found at \" << result1 << std::endl;\n  if (result2 == -1) std::cout << \"8 not found!\" << std::endl;\n  else std::cout << \"8 found at \" << result2 << std::endl;\n\n  return 0;\n}",
    "template <class T>\nint binSearch(const T arr[], int len, T what) {\n  int low = 0;\n  int high = len - 1;\n  while (low <= high) {\n    int mid = (low + high) / 2;\n    if (arr[mid] > what)\n      high = mid - 1;\n    else if (arr[mid] < what)\n      low = mid + 1;\n    else\n      return mid;\n  }\n  return -1; // indicate not found \n}",
    "proc binsearch(A : [], value) \n{\n        var low = A.domain.dim(0).low;\n        var high = A.domain.dim(0).high;\n        while (low <= high) \n        {\n                var mid = (low + high) / 2;\n\n                if A(mid) > value then\n                        high = mid - 1;\n                else if A(mid) < value then\n                        low = mid + 1;\n                else\n                        return mid;\n        }\n        return 0;\n}\n\nwriteln(binsearch([3, 4, 6, 9, 11], 9));",
    "(defn bsearch\n  ([coll t]\n    (bsearch coll 0 (dec (count coll)) t))\n  ([coll l u t]\n    (if (> l u) -1\n      (let [m (quot (+ l u) 2) mth (nth coll m)]\n        (cond\n          ; the middle element is greater than t\n          ; so search the lower half\n          (> mth t) (recur coll l (dec m) t)\n          ; the middle element is less than t\n          ; so search the upper half\n          (< mth t) (recur coll (inc m) u t)\n          ; we've found our target\n          ; so return its index\n          (= mth t) m)))))",
    "(defun binary-search (value array &optional (low 0) (high (1- (length array))))\n  (if (< high low)\n      nil\n      (let ((middle (floor (+ low high) 2)))\n        \n        (cond ((> (aref array middle) value)\n               (binary-search value array low (1- middle)))\n              \n              ((< (aref array middle) value)\n               (binary-search value array (1+ middle) high))\n              \n              (t middle)))))",
    "import std.stdio, std.array, std.range, std.traits;\n\n/// Recursive.\nbool binarySearch(R, T)(/*in*/ R data, in T x) pure nothrow @nogc\nif (isRandomAccessRange!R && is(Unqual!T == Unqual!(ElementType!R))) {\n    if (data.empty)\n        return false;\n    immutable i = data.length / 2;\n    immutable mid = data[i];\n    if (mid > x)\n        return data[0 .. i].binarySearch(x);\n    if (mid < x)\n        return data[i + 1 .. $].binarySearch(x);\n    return true;\n}\n\n/// Iterative.\nbool binarySearchIt(R, T)(/*in*/ R data, in T x) pure nothrow @nogc\nif (isRandomAccessRange!R && is(Unqual!T == Unqual!(ElementType!R))) {\n    while (!data.empty) {\n        immutable i = data.length / 2;\n        immutable mid = data[i];\n        if (mid > x)\n            data = data[0 .. i];\n        else if (mid < x)\n            data = data[i + 1 .. $];\n        else\n            return true;\n    }\n    return false;\n}\n\nvoid main() {\n    /*const*/ auto items = [2, 4, 6, 8, 9].assumeSorted;\n    foreach (const x; [1, 8, 10, 9, 5, 2])\n        writefln(\"%2d %5s %5s %5s\", x,\n                 items.binarySearch(x),\n                 items.binarySearchIt(x),\n                 // Standard Binary Search:\n                 !items.equalRange(x).empty);\n}",
    "/** Returns null if the value is not found. */\ndef binarySearch(collection, value) {\n    var low := 0\n    var high := collection.size() - 1\n    while (low <= high) {\n        def mid := (low + high) // 2\n        def comparison := value.op__cmp(collection[mid])\n        if      (comparison.belowZero()) { high := mid - 1 } \\\n        else if (comparison.aboveZero()) { low := mid + 1 }  \\\n        else if (comparison.isZero())    { return mid }      \\\n        else                             { throw(\"You expect me to binary search with a partial order?\") }\n    }\n    return null\n}",
    "let rec binarySearch (myArray:array<IComparable>, low:int, high:int, value:IComparable) =\n    if (high < low) then\n        null\n    else\n        let mid = (low + high) / 2\n\n        if (myArray.[mid] > value) then\n            binarySearch (myArray, low, mid-1, value)\n        else if (myArray.[mid] < value) then\n            binarySearch (myArray, mid+1, high, value)\n        else\n            myArray.[mid]",
    "recursive function binarySearch_R (a, value) result (bsresult)\n    real, intent(in) :: a(:), value\n    integer          :: bsresult, mid\n    \n    mid = size(a)/2 + 1\n    if (size(a) == 0) then\n        bsresult = 0        ! not found\n    else if (a(mid) > value) then\n        bsresult= binarySearch_R(a(:mid-1), value)\n    else if (a(mid) < value) then\n        bsresult = binarySearch_R(a(mid+1:), value)\n        if (bsresult /= 0) then\n            bsresult = mid + bsresult\n        end if\n    else\n        bsresult = mid      ! SUCCESS!!\n    end if\nend function binarySearch_R",
    "function binarySearch_I (a, value)\n    integer                  :: binarySearch_I\n    real, intent(in), target :: a(:)\n    real, intent(in)         :: value\n    real, pointer            :: p(:)\n    integer                  :: mid, offset\n    \n    p => a\n    binarySearch_I = 0\n    offset = 0\n    do while (size(p) > 0)\n        mid = size(p)/2 + 1\n        if (p(mid) > value) then\n            p => p(:mid-1)\n        else if (p(mid) < value) then\n            offset = offset + mid\n            p => p(mid+1:)\n        else\n            binarySearch_I = offset + mid    ! SUCCESS!!\n            return\n        end if\n    end do\nend function binarySearch_I",
    "include \"NSLog.incl\"\n\nNSInteger local fn BinarySearch( array as CFArrayRef, key as CFTypeRef )\nNSInteger lo = 0\nNSInteger hi = len(array) - 1\nwhile ( lo <= hi )\n  NSInteger i = lo + (hi - lo) / 2\n  CFTypeRef midVal = array[i]\n  select ( fn NumberCompare( midVal, key ) )\n    case NSOrderedAscending\n      lo = i + 1\n    case NSOrderedDescending\n      hi = i - 1\n    case NSOrderedSame:\n      return i\n  end select\nwend\nend fn = NSNotFound\n\nvoid local fn DoIt\n  CFArrayRef a = @[@1, @3, @4, @5, @6, @7, @8, @9, @10]\n  NSLog(@\"6 is at position %d\", fn BinarySearch( a, @6 ) ) // prints 4\nend fn\n\nfn DoIt\n\nHandleEvents",
    "// Creating and printing a List\nusing System;\nusing System.Collections.Generic;\n\nclass Geeks\n{\n    public static void Main()\n    {\n        List<string> l = new List<string> { \"C#\", \"Java\", \"Javascript\" };\n        \n        foreach (string name in l)\n        {\n            Console.WriteLine(name);\n        }\n    }\n}",
    "// C# program to Add elements to a LinkedList\nusing System;\nusing System.Collections.Generic;\n\nclass Geeks \n{\n    static void Main()\n    {\n        // Create a new LinkedList of strings\n        LinkedList<int> l = new LinkedList<int>();\n\n        // Add elements to the LinkedList\n\n        // Adds at the end\n        l.AddLast(3);\n        // Adds at the beginning\n        l.AddFirst(5);\n        // Adds at the end\n        l.AddLast(7);\n        // Adds at the end\n        l.AddLast(0);\n\n        // Display the elements in the LinkedList\n        Console.WriteLine(\"Elements in the LinkedList:\");\n        foreach(var i in l)\n        { \n          Console.WriteLine(i); \n        }\n    }\n}",
    "// C# program Implementing Stack class\nusing System;\nusing System.Collections.Generic;\n\npublic class Geeks\n {\n    public static void Main(string[] args)\n    {\n        // Create a new stack\n        Stack<int> s = new Stack<int>();\n\n        // Push elements onto the stack\n        s.Push(1);\n        s.Push(2);\n        s.Push(3);\n        s.Push(4);\n        \n        // Peek element\n        Console.WriteLine(\"Peek element of stack: \"+ s.Peek());\n        \n        // Pop elements from the stack\n        while (s.Count > 0) {\n            Console.WriteLine(\"Elements of Stack: \"+ s.Pop());\n        }\n    }\n}",
    "// C# program to demonstrates the working of queue\nusing System;\nusing System.Collections;\n\npublic class Geeks \n{\n    static public void Main()\n    {\n        // Create a queue\n        // Using Queue class\n        Queue q = new Queue();\n\n        // Adding elements in Queue\n        // Using Enqueue() method\n        q.Enqueue(\"GFG\");\n        q.Enqueue(10);\n        q.Enqueue(null);\n        q.Enqueue(3.5);\n        q.Enqueue(\"Geeks123\");\n\n      // Display the first element deque in the queue\n      Console.WriteLine(q.Dequeue());\n\n        // Accessing the elements\n        // of q Queue\n        // Using foreach loop\n        foreach(var i in q) \n        { \n          Console.WriteLine(\"Elements of Queue: \"+ i); \n        }\n    }\n}",
    "using System;\nusing System.Collections.Generic;\n\nclass Geeks\n{\n    static void Main()\n    {\n        // Create a priority queue with string elements and int priorities\n        PriorityQueue<string, int> pq = new PriorityQueue<string, int>();\n\n        // Enqueue elements with their priorities\n        pq.Enqueue(\"Low priority task\", 3);\n        pq.Enqueue(\"Medium priority task\", 5);\n        pq.Enqueue(\"High priority task\", 7);\n        pq.Enqueue(\"Highest priority task\", 10);\n\n        // Dequeue elements and print them\n        while (pq.Count > 0)\n        {\n            // Dequeue the highest priority element\n            string item = pq.Dequeue();\n            Console.WriteLine(\"Processing: \" + item);\n        }\n    }\n}",
    "// C# program to demonstrate how to \n// create and display a dictionary\nusing System;\nusing System.Collections.Generic;\n\nclass Geeks\n{\n    public static void Main()\n    {\n        // Creating a dictionary\n        Dictionary<int, string> sub = new Dictionary<int, string>();\n\n        // Adding elements\n        sub.Add(1, \"One\");\n        sub.Add(2, \"Two\");\n        sub.Add(3, \"Three\");\n\n        // Displaying dictionary\n        foreach (var ele in sub)\n        {\n            Console.WriteLine($\"Key: {ele.Key}, Value: {ele.Value}\");\n        }\n    }\n}",
    "// Creating and adding key, values to the sorted list\nusing System;\nusing System.Collections.Generic;\n\nclass Geeks\n{\n    public static void Main()\n    {\n        // Creating a SortedList\n        SortedList<int, string> sl = new SortedList<int, string>();\n\n        // Adding key-value pairs\n        sl.Add(3, \"Three\");\n        sl.Add(1, \"One\");\n        sl.Add(2, \"Two\");\n\n        // Displaying elements in sorted by key\n        foreach (var item in sl)\n        {\n            Console.WriteLine($\"Key: {item.Key}, Value: {item.Value}\");\n        }\n    }\n}",
    "// C# program to add elements to the hashtable\nusing System;\nusing System.Collections;\n\nclass Geeks \n{\n    static void Main()\n    {\n        // Create a new Hashtable\n        Hashtable ht = new Hashtable();\n\n        // Add key-value pairs to the Hashtable\n        ht.Add(\"One\", 1);\n        ht.Add(\"Two\", 2);\n        ht.Add(\"Three\", 3);\n\n        Console.WriteLine(\"Hashtable elements:\");\n        foreach(DictionaryEntry e in ht)\n        {\n            Console.WriteLine($\"{e.Key}: {e.Value}\");\n        }\n    }\n}",
    "#include <stdio.h>\nint main() {\n    int num;\n    printf(\"Enter an integer: \");\n    scanf(\"%d\", &num);\n\n    // true if num is perfectly divisible by 2\n    if(num % 2 == 0)\n        printf(\"%d is even.\", num);\n    else\n        printf(\"%d is odd.\", num);\n    \n    return 0;\n}",
    "#include <math.h>\n#include <stdio.h>\nint main() {\n    double a, b, c, discriminant, root1, root2, realPart, imagPart;\n    printf(\"Enter coefficients a, b and c: \");\n    scanf(\"%lf %lf %lf\", &a, &b, &c);\n\n    discriminant = b * b - 4 * a * c;\n\n    // condition for real and different roots\n    if (discriminant > 0) {\n        root1 = (-b + sqrt(discriminant)) / (2 * a);\n        root2 = (-b - sqrt(discriminant)) / (2 * a);\n        printf(\"root1 = %.2lf and root2 = %.2lf\", root1, root2);\n    }\n\n    // condition for real and equal roots\n    else if (discriminant == 0) {\n        root1 = root2 = -b / (2 * a);\n        printf(\"root1 = root2 = %.2lf;\", root1);\n    }\n\n    // if roots are not real\n    else {\n        realPart = -b / (2 * a);\n        imagPart = sqrt(-discriminant) / (2 * a);\n        printf(\"root1 = %.2lf+%.2lfi and root2 = %.2f-%.2fi\", realPart, imagPart, realPart, imagPart);\n    }\n\n    return 0;\n}",
    "#include <stdio.h>\nint main() {\n   int i, j, rows;\n   printf(\"Enter the number of rows: \");\n   scanf(\"%d\", &rows);\n   for (i = 1; i <= rows; ++i) {\n      for (j = 1; j <= i; ++j) {\n         printf(\"* \");\n      }\n      printf(\"\\n\");\n   }\n   return 0;\n}",
    "#include <stdio.h>\n\nint main() {\n\n  int n, i, flag = 0;\n  printf(\"Enter a positive integer: \");\n  scanf(\"%d\", &n);\n\n  // 0 and 1 are not prime numbers\n  // change flag to 1 for non-prime number\n  if (n == 0 || n == 1)\n    flag = 1;\n\n  for (i = 2; i <= n / 2; ++i) {\n\n    // if n is divisible by i, then n is not prime\n    // change flag to 1 for non-prime number\n    if (n % i == 0) {\n      flag = 1;\n      break;\n    }\n  }\n\n  // flag is 0 for prime numbers\n  if (flag == 0)\n    printf(\"%d is a prime number.\", n);\n  else\n    printf(\"%d is not a prime number.\", n);\n\n  return 0;\n}",
    "#include <stdio.h>\nint main() {\n\n  int i, n;\n\n  // initialize first and second terms\n  int t1 = 0, t2 = 1;\n\n  // initialize the next term (3rd term)\n  int nextTerm = t1 + t2;\n\n  // get no. of terms from user\n  printf(\"Enter the number of terms: \");\n  scanf(\"%d\", &n);\n\n  // print the first two terms t1 and t2\n  printf(\"Fibonacci Series: %d, %d, \", t1, t2);\n\n  // print 3rd to nth terms\n  for (i = 3; i <= n; ++i) {\n    printf(\"%d, \", nextTerm);\n    t1 = t2;\n    t2 = nextTerm;\n    nextTerm = t1 + t2;\n  }\n\n  return 0;\n}",
    "#include <stdio.h>\nint main() {\n  int n, reversed = 0, remainder, original;\n    printf(\"Enter an integer: \");\n    scanf(\"%d\", &n);\n    original = n;\n\n    // reversed integer is stored in reversed variable\n    while (n != 0) {\n        remainder = n % 10;\n        reversed = reversed * 10 + remainder;\n        n /= 10;\n    }\n\n    // palindrome if orignal and reversed are equal\n    if (original == reversed)\n        printf(\"%d is a palindrome.\", original);\n    else\n        printf(\"%d is not a palindrome.\", original);\n\n    return 0;\n}",
    "#include <stdio.h>\nint main() {\n   // printf() displays the string inside quotation\n   printf(\"Hello, World!\");\n   return 0;\n}",
    "void bubble_sort_variant(int arr[], int n, int ascending) {\n    for (int i = 0; i < n-1; i++) {\n        int swapped = 0;\n        for (int j = 0; j < n-i-1; j++) {\n            int condition = ascending ? (arr[j] > arr[j+1]) : (arr[j] < arr[j+1]);\n            if (condition) {\n                int temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n                swapped = 1;\n            }\n        }\n        if (!swapped) break;\n    }\n}",
    "void selection_sort_variant(int arr[], int n) {\n    for (int i = 0; i < n-1; i++) {\n        int min_idx = i;\n        for (int j = i+1; j < n; j++) {\n            if (arr[j] < arr[min_idx]) {\n                min_idx = j;\n            }\n        }\n        int temp = arr[min_idx];\n        arr[min_idx] = arr[i];\n        arr[i] = temp;\n    }\n}",
    "int binary_search_variant(int arr[], int n, int target) {\n    int left = 0, right = n - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        }\n        if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}",
    "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int* data;\n    int front;\n    int rear;\n    int capacity;\n} Queue;\n\nQueue* create_queue(int capacity) {\n    Queue* q = (Queue*)malloc(sizeof(Queue));\n    q->data = (int*)malloc(capacity * sizeof(int));\n    q->front = 0;\n    q->rear = -1;\n    q->capacity = capacity;\n    return q;\n}\n\nvoid enqueue(Queue* q, int item) {\n    if (q->rear < q->capacity - 1) {\n        q->data[++q->rear] = item;\n    }\n}\n\nint dequeue(Queue* q) {\n    if (q->front <= q->rear) {\n        return q->data[q->front++];\n    }\n    return -1;\n}",
    "#include <string.h>\n\nvoid string_reverse(char* str) {\n    int len = strlen(str);\n    for (int i = 0; i < len/2; i++) {\n        char temp = str[i];\n        str[i] = str[len-1-i];\n        str[len-1-i] = temp;\n    }\n}\n\nint string_length(char* str) {\n    int count = 0;\n    while (str[count] != '\\0') {\n        count++;\n    }\n    return count;\n}\n\nvoid string_copy(char* dest, char* src) {\n    int i = 0;\n    while (src[i] != '\\0') {\n        dest[i] = src[i];\n        i++;\n    }\n    dest[i] = '\\0';\n}",
]
